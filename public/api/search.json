[{"id":"475ab91d3f640698afc7f2e0661d00df","title":"Best Practice of using ref in React hooks and Why","content":"The idea for this blog post was sparked by a React quiz on Big Front-End titled ‚ÄúuseEffect.‚ÄùIn this article, we‚Äôll be discussing a best practice for using useRef in React, as well as delving into the reasons behind it.\n21. useEffect() IIimport React, &#123; useState, useRef, useEffect &#125; from 'react';\nimport ReactDOM from 'react-dom'\n\nfunction App() &#123;\n  const [show, setShow] = useState(true)\n  return &lt;div>\n    &#123;show &amp;&amp; &lt;Child unmount=&#123;() => setShow(false)&#125; />&#125;\n  &lt;/div>;\n&#125;\n\nfunction Child(&#123; unmount &#125;) &#123;\n  const isMounted = useIsMounted()\n  useEffect(() => &#123;\n    console.log(isMounted)\n    Promise.resolve(true).then(() => &#123;\n      console.log(isMounted)\n    &#125;);\n    unmount(); \n  &#125;, []);\n\n  return null;\n&#125;;\n\nfunction useIsMounted() &#123;\n  const isMounted = useRef(false);\n\n  useEffect(() => &#123;\n    isMounted.current = true;\n    return () => isMounted.current = false;\n  &#125;, []);\n\n  return isMounted.current;\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(&lt;App/>)\nAnswer (click me)\n\n\n// mount \nfalse\n// update\nfalse\n\nfunction Child(&#123; unmount &#125;) &#123;\n  const isMounted &#x3D; useIsMounted() &#x2F;&#x2F; mounting\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(isMounted) &#x2F;&#x2F; mounted\n    Promise.resolve(true).then(() &#x3D;&gt; &#123;\n      console.log(isMounted) &#x2F;&#x2F; update\n    &#125;);\n    unmount(); &#x2F;&#x2F; called when mounted, cause an update\n  &#125;, []);\n\n  return null;\n&#125;;\n\nfunction useIsMounted() &#123;\n  const isMounted &#x3D; useRef(false); &#x2F;&#x2F; mounting\n\n  useEffect(() &#x3D;&gt; &#123;\n    isMounted.current &#x3D; true; &#x2F;&#x2F; mounted\n    return () &#x3D;&gt; isMounted.current &#x3D; false; &#x2F;&#x2F; cleanup function called during next update\n  &#125;, []);\n\n  return isMounted.current; &#x2F;&#x2F; mounting\n&#125;\n\n\n\n\nWhy the above code does not work as expected?Primitive V.S. Reference Data type in JavaScriptWhen you create a copy of a primitive value, such as a string or a number, it is completely independent of the original value. In other words, changing the copy will not affect the original value in any way.\nHowever, when you make a copy of reference data, such as an object or an array, it‚Äôs like duplicating a key to a house. If you use this copied key to enter the house and make any changes to the interior, these modifications will be reflected for anyone else who also has access to this house.\nHow primitive data affected the useIsMounted hook?The value returned by useIsMounted is a snapshot of a primitive value during mounting, and any changes made to the ref after that moment will not affect this initially returned value.\nIt‚Äôs worth noting that refs does not automatically trigger a re-rendering. As a result, the initial value of isMountedfalse is called twice.\nClosure in hooksYou may also be curious about why console.log(isMounted) called with Promise is still false. To understand this, you need a little background knowledge about the execution context of each effect in React.\nYou can think of each render in React as a layer of dreams in the movie ‚ÄúInception‚Äù:Data that useEffect can directly access is not infinite in time and space - it can only read the execution context that was created, when the useEffect was called.\nSo, although each update cycle in React will create a new execution context, some hooks might still refer to its old context.\nThis is why the Promise console.log(isMounted) still showed the isMounted value, even after unmount() triggered a new update cycle.\nHow should we modify the above code to make it work as expected?Before answering this question, let‚Äôs do another quiz:What will be printed after runing the below code?\nimport React, &#123; useState, useRef, useEffect &#125; from \"react\";\nimport ReactDOM from 'react-dom/client';\n\nfunction App() &#123;\n  const [show, setShow] = useState(true);\n  return &lt;div>&#123;show &amp;&amp; &lt;Child setShow=&#123;setShow&#125; />&#125;&lt;/div>;\n&#125;\n\nfunction Child(&#123; setShow &#125;) &#123;\n  const isMounted = useIsMounted();\n\n  useEffect(() => &#123;\n    console.log(isMounted.current);\n    setShow(() => &#123;\n      console.log('update state');\n      return false;\n    &#125;);\n  &#125;, []);\n\n  return null;\n&#125;\n\nfunction useIsMounted() &#123;\n  const isMounted = useRef(2);\n\n  useEffect(() => &#123;\n    isMounted.current += 3;\n    return () => &#123;\n      isMounted.current *= 2\n      console.log(isMounted.current);\n    &#125;;\n  &#125;, []);\n\n  return isMounted;\n&#125;\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root')\n);\nroot.render(&lt; App />)\nAnswer (click me)\n\n\n// mounted\n5\n\"update state\"\n// after state updated\n10\n\n\n\n\nExplanationInstead of returning the isMounted.current value, we are now returning the entire isMounted object. This means, although our reference key (the ref object) was created during mounting, we still can refer to an updated version of the isMounted ref in the componentDidMount lifecycle.\nIn this case, the logged isMounted.current values are as expected:\n\n5: After mounting, the isMounted.current value is 5, which is updated by the useEffect function in the custom hook.\n10: When setShow is triggered, it triggers a re-render of the App component, which causes the Child component to be unmounted and the cleanup function of useIsMounted to be called.\n\n(A tip on useEffect cleanup: React will call your cleanup function each time before the Effect runs again, before the related component unmount)\nAs a result, isMounted.current &#x3D; 10    \nA secret behind useRefThe ref returned by useIsMounted references the same ref object during each rendering (to understand it, try to log isMounted in the above code).\njsximport React, &#123; useState, useRef, useEffect &#125; from &quot;react&quot;;\nimport ReactDOM from &#39;react-dom&#x2F;client&#39;;\n\nfunction App() &#123;\n  const [show, setShow] &#x3D; useState(true);\n  return &lt;div&gt;&#123;show &amp;&amp; &lt;Child setShow&#x3D;&#123;setShow&#125; &#x2F;&gt;&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nfunction Child(&#123; setShow &#125;) &#123;\n  const isMounted &#x3D; useIsMounted();\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(isMounted);\n    setShow(() &#x3D;&gt; &#123;\n      console.log(&#39;update state&#39;);\n      return false;\n    &#125;);\n  &#125;, []);\n\n  return null;\n&#125;\n\nfunction useIsMounted() &#123;\n  const isMounted &#x3D; useRef(2);\n\n  useEffect(() &#x3D;&gt; &#123;\n    isMounted.current +&#x3D; 3;\n    return () &#x3D;&gt; &#123;\n      isMounted.current *&#x3D; 2\n      console.log(isMounted);\n    &#125;;\n  &#125;, []);\n\n  return isMounted;\n&#125;\n\nconst root &#x3D; ReactDOM.createRoot(\n  document.getElementById(&#39;root&#39;)\n);\nroot.render(&lt; App &#x2F;&gt;)\n\nCan you take a guess on what will be logged by this code?\nAnswer (click me)\n\n\n&#123;current: 10&#125;\n'update state' \n&#123;current: 10&#125;\n\n\n\n\nExplanationTo understand this, let‚Äôs look at the source code of updating refs in React:\nfunction updateRef&lt;T&gt;(initialValue: T): &#123;current: T&#125; &#123;\n  const hook &#x3D; updateWorkInProgressHook();\n  return hook.memoizedState;\n&#125;\nAs you can see, the updated ref object always refers to the initial one.This explains why you see &#123;current: 10&#125; before ‚Äòupdate state‚Äô:The ref always points to the same object, and &#123;content:10&#125; is showing its most recent value.If you want a ref to reflect data changes more accurately, you can convert the ref object to a string or call ref.current.\nRecap: best practice of returning a ref in custom hooks\nreturn the ref object itself\ncall ref.current to access the latest value\n\n","slug":"best-practice-of-useRef-and-why","date":"2023-02-28T20:54:29.000Z","categories_index":"","tags_index":"","author_index":"flaming-cl"},{"id":"e3fb0e6e7c44f4a9d38a4589b5569d51","title":"Single-threaded JavaScript","content":"This article will illustrate synchronous&#x2F;asynchronous and micro&#x2F;macro tasks.\nSynchronous and Asynchronous TasksIn JavaScript, we have synchronous and asynchronous tasks.\nSynchronous TasksSynchronous tasks are processed immediately, and they can block JavaScript execution until the running task is completed.\nAsynchronous TasksAsynchronous tasks, such as I&#x2F;O or network requests, often require interaction with threads other than the JS engine main thread to obtain data for incoming execution.\nAs the main thread is not responsible for I&#x2F;O or network jobs, it really doesn‚Äôt need to wait for completion of long-running asynchronous tasks. To improve efficiency, JavaScript asks asynchronous tasks to yield the main thread for the next task, and will execute on ready asynchronous callbacks later.\n\nIllustration for Asynchronous TasksTo better understand asynchronous tasks, let‚Äôs look at an example of working as a counter staff at McDonald‚Äôs. Here is a typical scenario of a counter staff‚Äôs job:\n\nhave customers waiting in line before serving them\nserve customer A to order food at the counter\ntell customer A to wait for food to be cooked, and start serving customer B\nwhen customer A‚Äôs meal is ready, notify A to be back, pass meals to A and complete service\n\nLet‚Äôs take a look at how working as a counter staff at McDonald‚Äôs is similar to task processing in JavaScript:\n\nJavaScript is single-threaded, handling one task at a time.The counter staff only serves one customer at a time.\nJavaScript passes asynchronous tasks to web APIs, let callbacks of async calls to be executed later, and begin processing the next task.Food ordered by customer A is not cooked yet. The counter staff asks the kitchen to prepare the meal, tells customer A to go back later, and start serving customer B.\nJavaScript keeps on ready asynchronous tasks waiting in queue before execution.The way customers wait in queue is quite similar to how on ready asynchronous tasks wait in the task queue, as they all follow a first in first out manner.\n\nIllustration for Synchronous TasksIn JavaScript, synchronous tasks are executed immediately and before the execution of async tasks.\nThe counter staff‚Äôs analogy can also be used to explain synchronous tasks, as if food ordered by customer B is in the holding cabinet and ready for picking up.In this case, the counter staff can directly pass the meal to and finish service for customer B, while customer A is still waiting for the meal to be ready.\n\nInside asynchronous tasks: Microtask and MacrotaskTo illustrate this, let‚Äôs modify our previous story a bit. Now the McDonald‚Äôs is inside a train station. It is common that some customers have their train leaving soon and ask other customers if they can cut in line to place their order soon.\nThis scenario emphasizes the need for having both microtasks and macrotasks: we want to make it possible for high priority tasks to cut in line and be executed ahead of less prioritized ones.\nAs a result, microtasks are designed to be prioritized and executed earlier, while macrotasks are less urgent and can be deferred. In other words, microtasks will be executed before macrotasks in JavaScript.\nSo far, we can infer the execution order of the three types of tasks is: \n\n\n\n\n\n\n\n\n\nsynchronous tasks -&gt; microtasks -&gt; macrotasks.\n","slug":"single-threaded-javascript","date":"2023-02-08T19:33:14.000Z","categories_index":"","tags_index":"JavaScript","author_index":"flaming-cl"},{"id":"d7e769e271f05380381ff271e09b897f","title":"Is setState asynchronous?","content":"Whether setState is synchronous or asynchronous has become a clich√© these days.   \nHowever, as React is constantly evolving, a frontend programmer‚Äôs answer to this question can still demonstrate some deep understanding of the framework.\nToday, let‚Äôs gain a deeper understanding of some implementation mechanisms behind React.\nIdeas of this articleAlthough setState() is not inherently asynchronous, React has designed it to behave like an asynchronous function for certain reasons. This article will:\n\nSummarize why setState() behaves like an asynchronous function.\nExplore the reasons why synchronous setState() can behave asynchronously.\nClarify whether setState() behaves like a microtask or a macrotask.\n\nWhy setState() act like an async function(This section is a recap on Dan Abramov‚Äôs response to the question posed in RFClarification: why is setState asynchronous?)\nIn daily life, we tend to prioritize tasks that require immediate attention over those that can be completed later. Similarly, not every state update triggered by setState() is of the highest priority.\nThis is where the first reason of asynchronously setState comes into play: priority scheduling.\n\n\n\n\n\n\n\n\n\nReact could assign different priorities to setState() calls depending on where they‚Äôre coming from: an event handler, a network response, an animation, etc.\nReason 1: ensures concurrent featuresExampleImagine you‚Äôre editing a post on social media while getting a dozen of new notification messages.If there are 100+ or even 500+ new messages, there may be no response to your keyboard input, as the browser is busy updating new notifications.\nFor the above situation, what can you do to ensure smooth text input for users?A good practice is: giving low priority to message updates, as they are less important in this case. And when a message update encounters a high priority event, we will ask the former one to yield the main thread.\nWhy asynchronous setState() benefits prioritized rendering (concurrent features) in React?This is because async-like setState() makes concurrent features possible, by delaying execution of low priority task and making room for high priority ones.\nReason 2: avoid dirty dataBesides performance optimization, avoiding dirty data is another reason not to run setState() in a synchronous way. To understand this, we need to talk about the core value of React first.\nReact In Theory\nFor React, its most fundamental principle evolved from this formula:\n\n\n\n\n\n\n\n\n\nUI &#x3D; f(state)\nThe concept behind this idea is straightforward: if you have the same input states for your application, it should always produce the same user interface (UI).\nHowever, running setState() synchronously may violate React‚Äôs pure-function-like update processes:\nIt is hard to ensure consistency on synchronously updated states and their props.When a sync setState() is fired, its related props have to wait for reconciliation or flushSync to happen for corresponding updates. Such inconsistency can lead to unpredictable state updates in a React App.\nWhat makes sync setState() act asynchronouslyEvery time renderRoot or setState is triggered, React doesn‚Äôt immediately start rendering in a React App. Instead, React will first schedule the updates, assigning different priority levels to each task and combining multiple tasks into one.\nBecause of this, synchronous setState() calls are collected in an updateQueue.The way updateQueue implemented gives setState() asynchronous behaviors: \n\nnormal setState() calls will be handled within a micro task queue\nconcurrent featured setState() calls are handled in a macro task queue\n\nYou might be wondering how to prove that setState() itself is synchronous?A classic example is: Prior to React 18, if you called setState() within setTimeout(), you would notice that it executes immediately. (In React 18, this issue has been addressed, and setState() calls made within setTimeout() are now asynchronous as well)\nMicrotask or MacrotaskWhen updating, if React encounters a high-priority task, it will not execute the next low-priority task and schedule the highest-priority task to be executed.\nHow does React implement this (let high priority tasks cut in line)?When it comes to the JavaScript event loop, a common method of interrupting is to let the newly added microtask interrupt the execution of existing macro tasks.We also know that React update functions (setState) are often processed as microtasks.\nTake the concurrent feature as an example:To interrupt low-priority tasks, we mark the tasks in a concurrent feature API as low-priority and put them in a macro task queue.In this way, when higher-priority microtask updates appear, they can jump ahead of the current low-priority macro tasks and be processed first.\nReference\nRFClarification: why is setState asynchronous?\nAutomatic batching for fewer renders in React 18\n\n","slug":"async-setState","date":"2023-02-07T20:07:27.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"fb9f2e7d2bf6b72bb67731a251124487","title":"Questions About React concurrent features","content":"Do React concurrent features mean multitasking?\nNo. React concurrent features are not about multitasking.\nThis is because the JavaScript engine is single-threaded (can only do one thing at one time).\nSo there is no magic for React to simultaneously handle user events while rendering a large list.\n\nIf so, what does React do to avoid stutters when running CPU heavy tasks?In fact, React tries to avoid CPU bottlenecks by running one task, stopping it, running another, and so forth.Sounds like a micro operating system, right? \nBut concurrent features will not allow tasks to freely compete for sources.Instead, they will label different tasks with different priority: low priority running tasks will yield the main thread to high priority tasks to ensure performance.\nThis is quite similar to how we answer a second phone call:\n\n\n\n\n\n\n\n\n\nAssume there comes a food delivery call, while we are calling a friend for a casual chat.Since a food delivery call is more urgent than a casual chat, we hold the chat and answer the delivery call.\n\nReact does the same thing. It can pause a less prioritized rendering task and yield to more urgent tasks, such as keyboard events. This is implemented as concurrent features since React 18.\nCan you give some examples about React concurrent features?Concurrent features: startTransition(), useTransition(), useDeferredValue()By using the above APIs, you are telling React to give lower priority to things you put in them. \n1ÔºâuseDeferredValue(value)\n\nexample: input value of a search bar\nresult: updates of the input value will be deferred, just like what ‚Äúdebounce‚Äù does\n\n2ÔºâstartTransition(callback)\n\nexample: a function to update a large list\nresult: When updating the large list, if there comes a keyboard event, React will pause the ongoing update and turn to the user event.\n\nWhat enables React to run the concurrent features?Time slicing.After V16, React started to embrace time slicing to ensure an interruptible render phase.This means React can insert urgent browser tasks among small tasks from the render phase to avoid stutter.\nTo understand more about time slicing, go to this post\nReferences[1] Visualization of async rendering and synchronous rendering in React, Andrew Clark[2] useTransition, React Docs[3] useDeferredValue, React Docs\n","slug":"simple-ideas-about-React-Concurrent-mode","date":"2023-02-06T17:21:10.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"adfd66f4376cbd49d3c1a235fa3bacdf","title":"React little by little 3 - Render Phase","content":"Recap: Time Sliced Work LoopFrom the time slicing post, we have known React implements an interruptible render phase by a conditional while loop: once shouldYield turns True, the current reconciliation job can be paused, leaving the main thread to more prioritized jobs, like a user event.\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\nToday we are going to talk about the render phase of React, which is implemented via performUnitOfWork inside each work loop.\nQuestion: Do you think where we should put our code for the commit phase?\n\nWe should put it outside the breakable while loop.      \nThis is because the commit phase can not be paused: we do not want to see our App rendered with some half updated states.\n\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        performUnitOfWork(\n            workInProgress\n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    commitWork(); // the commit phase\n    requestIdleCallback(workLoop)\n&#125;\n\n\n\n\nThe Render PhasePerformUnitOfWork (the render phase) mainly does two things: beginWork and completeWork. Its code could be written like this:\nlet workInProgress = null;\n\nfunction performUnitOfWork(fiber: FiberNode) &#123;\n    const next = beginWork(fiber);\n    fiber.memorizedProps = fiber.pendingProps;\n\n    if (next === null) &#123;\n        completeUnitOfWork(fiber);\n    &#125; else &#123;\n        workInProgress = next;\n    &#125;\n&#125;\nAn Overview of PerformUnitOfWorkBefore understanding key responsibilities of performUnitOfWork, we first have an overview about how React calls performUnitOfWork to reconcile a Fiber tree.\n\nbeginWorkWhat does beginWork do?Each time, performUnitOfWork calls beginWork with the WIP (work in progress) fiber node to do the reconciliation job and return a reconciled child Fiber node (return null if no child). \nExecution order of beginWork calls  The execution order of beginWork calls is similar to a preorder traversal of a tree, like succession to a monarchy‚Äôs throne:\n\n\n\n\n\n\n\n\n\n1st kid ‚û° 1st grandchildren ‚û° 1st great-grandchildren ‚û° ‚Ä¶ ‚û° the 1st no-kid offspring‚û° second in line sibling ‚û° 1st kid of second in line sibling ‚û° ‚Ä¶\n  True or False: The 1st Fiber node enters completeWork is the deepest node in a Fiber tree. \n          \n          False. The first Fiber node enters completeWork is the left most leaf node in an App.\n          \n     \n\nAfter beginWorkWhen beginWork finishes its work, we update the current props in the Fiber node.The next step depends on whether the current Fiber node has a child node:\n\nchild ‚úÖ, performUnitOfWork will pass the child to the next performUnitOfWork call.\nchild ‚ùå, performUnitOfWork will leave the current node to completeUnitOfWork.\n\ncompleteUnitOfWorkThen, performUnitOfWork calls completeUnitOfWork:\nfunction completeUnitOfWork(fiber: FiberNode) &#123;\n    let node: FiberNode | null = fiber;\n\n    do &#123;\n        completeWork(node); \n        const sibling = node.sibling;\n\n        if (sibling !== null) &#123;\n            workInProgress = sibling;\n            return;\n        &#125;\n\n        node = node.return;\n        workInProgress = node;\n    &#125; while (node !== null);\n&#125;\nInside completeUnitOfWork, we first call completeWork to create a DOM instance for the WIP fiber node and handle its effects&#x2F;flags. After that, the while loop has 3 options:\n\nOption 1, the WIP node has a sibling node ‚úÖ: beginWork(sibling)\nOption 2, sibling node ‚ùå , parent node ‚úÖ : completeWork(parent)\nOption 3, sibling node ‚ùå , parent node ‚ùå : stop the work loop\n\nTest your understandingNow we have had an overview of the reconciliation work loop.To test how you understand what we have learned, give it a whirl on the following question.\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nQuestion: Please list all the beginWork and completeWork calls of this App during a render phase in sequence.\nFor example, 1. beginWork(hostFiberRoot) 2. beginWork(App) 3. beginWork(div)\n\n\n\n\nNote: DIV is a host component. ‚Äúlittle by little‚Äù is a text component.\nInterview TrickYou may wonder why we spend so much time on a general understanding of the render phase. By understanding it, you can solve many interview questions on the rendering path of an APP.\nLet us look at an interview question:\nimport React, &#123; useEffect &#125; from \"react\";\n\nfunction A() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount A\");\n  &#125;, []);\n  console.log(\"A\");\n  return &lt;B />;\n&#125;\n\nfunction B() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount B\");\n  &#125;, []);\n  console.log(\"B\");\n  return &lt;C />;\n&#125;\n\nfunction C() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount C\");\n  &#125;, []);\n  console.log(\"C\");\n  return null;\n&#125;\n\nfunction D() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount D\");\n  &#125;, []);\n  console.log(\"D\");\n  return null;\n&#125;\n\nfunction App() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount App\");\n  &#125;, []);\n  console.log(\"App\");\n  return (\n    &lt;div>\n      &lt;A />\n      &lt;D />\n    &lt;/div>\n  );\n&#125;\n\nexport default App;\nWhat does the above code snippet output by calling console.log?App    \nA    \nB    \nC    \nD     \nMount C    \nMount B     \nMount A    \nMount D   \nMount App  \n\n\nConsole.log(‚ÄúX‚Äù) is called when we enter a component. \n\n\n\n\n\n\n\n\nOrders of entering a component are the same as how we call beginWork (like a preorder traversal).\n\nConsole.log(‚ÄúMount X‚Äù) inside useEffect(() &#x3D;&gt; {}, []) is called after a component is rendered. \n\n\n\n\n\n\n\n\nOrders of rendering a component are the same as how we call completeWork (like a postorder traversal).\n\n\nBut can you tell the reasons for your answer? It is time to take a closer look at beginWork and completeWork.\n","slug":"react-render-phase","date":"2023-01-13T13:41:00.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"6f24cb5d48daf65e1958eb9ee89fd0c6","title":"Trie based router","content":"Why trie based routerIf you do not have performance issues, adopting a trie based router might become a premature optimization. In this case, Regex based routing is fast enough, as Regex are compiled down to native code in modern browsers, like Chrome.\nHowever, if you feel tradition MVC routing results in performance pressure on your web App, you can take a look at trie based router. Here is an example from Ayende Rahien.   \n\n\n\n\n\n\n\n\n\nTraditional MVC routing infrastructure can consume a significant amount of time,leaving little time for handling actual requests.By using a trie based router, it is possible to reduce time spent on routing infrastructure,and increase time spent on actual request handling.\nHow to implement Router trieA route mainly does two things: registering a route with a function; matching a route.Here we use trie to register and match routes.\n1. Register a routeFirst, split the route into an array of routes.e.g. ‚Äú&#x2F;courses&#x2F;:id‚Äù &#x3D;&gt; [‚Äúcourses‚Äù, ‚Äú:id‚Äù]\nconst add = (route) => &#123;\n    if (typeof route !== 'string') &#123;\n        throw TypeError('route should be string');\n    &#125;\n    this.currentRoutes = splitRoute(route);\n    return this.createTrieNode(0, this.trie);\n&#125;\nNext, recursively add each segment of the route array to our trie.\n\n1&#x2F; Handle ‚Äú:‚Äù for dynamic values, ‚Äú*‚Äù for wildcard (any value)\n2&#x2F; If a segment is found in our trie, check the next one\n‚Äúcourses‚Äù is shared in the trie, if we have both courses&#x2F;:id and courses&#x2F;ranking\n\n\n3&#x2F; If not found, create a trie node for this segment const createTrieNode = (index, trie) => &#123;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n        \n    let node = null;\n    if (HAS_SPECIAL_SYMBOL) &#123;\n        handleSpecialSymbol();\n    &#125; else if (trie.nodes.has(thisRoute)) &#123;\n        node = trie.nodes[thisRoute];\n    &#125; else &#123;\n        node = this.createNewNodes();\n        trie.nodes[thisRoute] = node;     \n    &#125;\n\n    return this.createTrieNode(index + 1, node);\n&#125;\n\n2. Match a routeLogics for match() a route is quite similar to add().The main difference is in match() we also handle params for a route (if found).\nconst match = (route) => &#123;\n    this.currentRoutes = splitRoute(route);\n    this.currentParams = &#123;&#125;;\n        \n    const node = search(0, this.trie);\n    if (!node) return undefined;\n        \n    node = new Map(node);\n    node.params = this.currentParams;\n    return node;\n&#125;\nWhat does search() do?If a node is found, search() recursively calls itself, with the next segment and the matching node as arguments.\nconst search = (index, trie) => &#123;\n    if (trie === undefined) return trie;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n\n    if (trie.nodes.has(thisRoute)) &#123;\n        return search(index + 1, trie.nodes[thisRoute]);\n    &#125;\n\n    if (trie.name) &#123;\n        // add params\n    &#125;\n\n    if (trie.wildCard) &#123;\n        // add params\n    &#125;\n\n    return search(index + 1);\n&#125;\nFor full implementation, check here.\nReferences[1] Trie based routing, Ayende Rahien[2] A composable trie based router, Wayfarer[3] Trie based routing instead of Regex based routing, React router\n","slug":"dsa_for_web_trie_router","date":"2022-12-21T18:04:15.000Z","categories_index":"","tags_index":"DSA for web dev","author_index":"flaming-cl"},{"id":"62708f443f37b12bd82e694a7acb90fc","title":"React little by little 2 - Fiber Tree","content":"\n\n\n\n\n\n\n\n\nPlato said life is like being chained up in a cave, forced to watch shadows flitting across a stone wall.\nWe are not talking about philosophy today, but use Allegory of the Cave to describe the relationship between React applications and what is under the hood:\nReact applications we see today are mainly results of the render phase and the commit phase.Just like shadows in the eyes of prisoners are results of sun reflection and real world activities.\n\nWhat is under the hoodBefore we see any changes in an application, React does three things: Scheduling, Rendering and commit. What are these? In plain English, they are just:\n\nScheduling üóìÔ∏è: schedule and manage tasks to run\nRender üîé üå≤ üèÅ: figure out changes made in React applications\nCommit ‚òëÔ∏è : apply these changes to browser DOM\n\nTo understand React, we will start from the render phase. To understand the render phase, we need to understand the React Fiber data structure.\nIn this post, I will cover 2 topics about React Fiber:\n\nHow does React create the first Fiber node?\nWhat are the main properties of a Fiber node?\n\n\nHow does React build a Fiber Tree from the first Fiber node during mounting?\n\nInside React Reconciliation: Fiber TreesFrequent DOM manipulations are expensive for complicated web applications.In this case, we had better only applies changes to the real DOM during state&#x2F;props updates.But changes might spread all over the whole tree, to locate them, we can compare two versions (previous &amp; current) of a virtual DOM tree. This process is called Reconciliation in React.\nQuestion: What is a virtual DOM tree called in React 18?Fiber tree, a singly linked list tree.To understand Fiber tree, we can start from the most basic unit of it, a Fiber node.\nHow does React generate the first Fiber nodeA Fiber node is just a plain JavaScript object.But it may be the object you have never seen before, since it is not exposed to React users.Let us start from something we are familiar with‚ÄîReact Components.\nReact Components, Elements, Fiber NodeThe process of building a Fiber node is the process of converting React Component JSX &#x3D;&gt; a React Element &#x3D;&gt; a Fiber node. \n JSX \n\n\n\n\n\n\n\n\n\n\n\nA syntax extension to JavaScript that allows writing HTML in React components\n\n\n\n React Element \n\n\n\n\n\n\n\n\n\n\n\nThe smallest building blocks of React apps, describing what to render to a React UI environment\n\n\n\n Fiber node \n\n\n\n\n\n\n\n\n\n\n\nA basic unit of work to locate or commit changes in React applications\n\n\n\nFrom React Component to React ElementWe know that React components return JSX. But what does JSX produces?\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\nJSX produces React elements.For example, App is a React component; &lt;App &#x2F; &gt; is a React element in the form of JSX.If you put &lt;App &#x2F; &gt; into Babel, you will get:\n/*#__PURE__*/React.createElement(App, null);\nIt is just a JavaScript object:\nconsole.log(React.createElement(App, null));\n\n/*\n&#123;\ntype: ∆í App(), // e.g. functional component, or HTML tag type like div, p, h1\nkey: null, // e.g. keys you set up in a React component\nref: null,\nprops: &#123;&#125;, // e.g. React component props\n_store: &#123;&#125;,\n_owner: null,\n&#125;\n*/\nTake a closer look at this React Element object, and answer this question:\nCan a React Element be the unit of work to do the Reconciliation job? \n\n\nNo. For Reconciliation, a React element can be too static and isolated:\n\nData stored in it is comparatively static. It mainly explains what this React element looks like.\n\n\n\n\n\n\n\n\nFor reconciliation, we need more dynamic data about its state&#x2F;effect changes or priority scheduling.\n\nIt does not show connections with its children&#x2F;sibling&#x2F;parent Elements.\n\n\n\n\n\n\n\n\nWhen we have finished processing it, we have no way to find the next unit of work.\n\n\nFor reconciliation, we need an upgraded version of React Element. That is where Fiber node comes in.\n\n\n\nFrom React Element to Fiber nodeWe can create a Fiber root node for the React element &lt;App &#x2F; &gt;, by calling:\nconst rootElement = document.getElementById(\"root\");\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nTo see what is inside a Fiber node (React 18.2.0), you can try this:\nconst reactContainerKey = Object.keys(rootElement)[0]; // __reactContainer$cjvrzgbs4i4 \nconsole.log(rootElement[reactContainerKey]) // Fiber root node\n\nTo make it easier to understand, I break down properties of a Fiber node object into 4 parts:\n\nBasic Fiber node info\nTree pointers\nEffect &amp; reconciliation\nScheduling\n\nHere is a cheatsheet for a React Fiber node:\n\nAt this moment, just take a glimpse at this Fiber node.Knowing it also tells something about Reconciliation, Scheduling and its neighbor nodes is enough at this moment. \nHow does React build a Fiber tree from the Fiber root node?Now we have created a Fiber root node.Before mount (first time rendering), React does three things:\n\nCreate a Fiber root node for the whole App.\nCreate a Host Fiber node for the rootElement DOM element.\nLink the Fiber root node with the host Fiber node, using the ‚Äúcurrent‚Äù pointer.\n\n\nDuring mounting, React will also create an alternative host Fiber node.This is different from our existing one, as its child node is not null but a tree of Fiber nodes, which correspond to each React element listed in the app.\nThe alternative host Fiber node, along with its descendant Fiber nodes, is called the workInProgress (WIP) Fiber tree.\nLook at the above pic, you may wonder: Why two host root nodes? What is double buffering? \n\n\nHere is an illustration from game programming patterns:\n\n\n\n\n\n\n\n\n\nImagine we are watching a play.When scene 1 is finished, we will have a 5-minute scene transition, leaving the audience in dark and silence. This is normal in a real world theatre play.But if we leave game players in a black screen for a few seconds, this may drive people nuts.\nIn both game programming and React, we hope to avoid this blank transition by a technique called Double Buffering.Back to our theatre play example, we avoid the silent transition by running two stages (double buffering): \n\nstage A is on show for the current scene \nstage B is adjusting lights or removing&#x2F;changing play props for the next scene\n\nOnce the current scene is finished on stage A, we immediately light on stage B to go to the next scene seamlessly. Now stage A is in dark preparing the next scene settings. \nSo in React, double buffering means switching between the current fiber tree and a workInProgress fiber tree for seamless transitions between rendering.\n\n\n\n\nWe therefore have finished a simple tour about first time rendering in React.\nReferences[1] Double Buffering[2] Allegory of the Cave\n","slug":"react-fiber-tree","date":"2022-11-23T04:40:35.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"87eff45d285eb86c0eaa49c27b6abfb9","title":"Exploring the Benefits of Locality in Memory","content":"As stated in Computer Systems: A Programmer‚Äôs Perspective:\n\n\n\n\n\n\n\n\n\nWell-written computer programs tend to exhibit good locality\nWhat is localityIf you haven't heard of locality, click here.\n\n \n\n\n\n\n\n\n\n\n\nLocality is often described as temporal locality and spatial locality.\n1. Spatial localityGood practice: reference a memory location and then its neighbors\nPoor spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (j &#x3D; 0; j &lt; N; j++)\n    for (i &#x3D;0: i &lt; M; i++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code jumping through elements of different rows in the matrix.\nAssume you are going to buy groceries and books. With poor spatial locality, you  do this:\n\nbuy tomatoes first, and go to a book store for a Math book.\nback to the grocery store for milk, and go to the book store again for a comic book.\n\nBetter spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (i &#x3D; 0; i &lt; M; i++)\n    for (j &#x3D;0: j &lt; N; j++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code reads all the elements in a row and then the next row.\nBack to our grocery example, this time you buy everything from the grocery store first.Later to buy all the books you need from the book store.\n2. Temporal localityGood practice: reference a memory location multiple times\nGood temporal localityOur code above repeatedly reference the same variables (i, j) and enjoy good temporal locality.\n\n\n\nExample in JavaScriptCan we have good spatial locality if we loop cols before rows like this?\nfunction farAccess(data) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      data[j * ROWS + i].x = 1;\n    &#125;\n  &#125;\n&#125;\nLet‚Äôs look at an example given by Yonatan Kra:\n1&#x2F; Create an array of 1,000,000 instances.\nconst ROWS = 1000, COLS = 1000, REPEATS = 1000;\nconst testArray = new Array(ROWS * COLS).fill(0).map((a, i) => new Boom(i));\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n2:Boom &#123;id: 2, x: 0&#125;\n3:Boom &#123;id: 3, x: 0&#125;\n...\n999999:Boom &#123;id: 999999, x: 0&#125;\n2&#x2F; Create a tricky array.\nconst trickyArray = new Array(ROWS * COLS).fill(0);\nfor (let col = 0; col &lt; COLS; col++) &#123;\n    for (let row = 0; row &lt; ROWS; row++) &#123;\n        trickyArray[row * ROWS + col] = arr[col * COLS + row];\n    &#125;\n&#125;\n3&#x2F; Write two functions with good&#x2F;bad spatial locality. \nfunction runGoodSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; ROWS; i++) &#123;\n    for (let j = 0; j &lt; COLS; j++) &#123;\n      arr[i * ROWS + j].x = 0;\n    &#125;\n  &#125;\n&#125;\n\nfunction runPoorSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      arr[j * ROWS + i].x = 0;\n    &#125;\n  &#125;\n&#125;\n4&#x2F; Test performance\nfunction timeit(cb, type) &#123;\n    console.log(`Started data $&#123;type&#125;`);\n    const start = performance.now();\n    for (let i = 0; i &lt; repeats; i++) &#123;\n        cb();\n    &#125;\n    const end = performance.now();\n    console.log(\n        `Finished data locality test run in $&#123;((end - start) / 1000).toFixed(\n            4\n        )&#125; seconds`\n    );\n    return end - start;\n&#125;\n\ntimeit(() => runGoodSpatialLocality(testArray), \"good\");\nsetTimeout(() => &#123;\n    timeit(() => runPoorSpatialLocality(testArray), \"bad\");\n    setTimeout(() => &#123;\n        timeit(() => runPoorSpatialLocality(trickyArray), \"tricky\");\n    &#125;, 2000);\n&#125;, 2000);\n5&#x2F; ResultsThe second function call with bad locality is more than 2 times slower.This is because it makes the CPU chasing its tail to jump between N (length of a row) stride of memory, during each access.But why the third function call with bad locality and the tricky array is still fast? \nFinished good data locality test in 5.1799 seconds\nFinished bad data locality test in 13.9438 seconds\nFinished tricky data locality test in 5.4242 seconds\nBecause our tricky array still access 1-stride of an array:Although we access the whole array by index 0, 1000, ‚Ä¶our tricky array just put elements with 1-stride of memory on index 0, 1000, 2000, ‚Ä¶ like this:\n// trickArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1000, x: 0&#125;\n1000:Boom &#123;id: 1, x: 0&#125;\n1001:Boom &#123;id: 1001, x: 0&#125;\n2000:Boom &#123;id: 2, x: 0&#125;\n...\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n1000:Boom &#123;id: 1000, x: 0&#125;\n2000:Boom &#123;id: 1000, x: 0&#125;\n...\nNow we get the answer: Yes.Even though we run a COL loop first and a ROW loop later,as we still access a memory location and its neighbors in memory,we can have good spatial locality.\nReferences[1] Computer Systems: A Programmer‚Äôs Perspective[2] Memory in Javascript‚ÄîBeyond Leaks[3] Stride, Caches, CS61C lab12\n","slug":"locality","date":"2022-11-10T18:04:15.000Z","categories_index":"","tags_index":"","author_index":"flaming-cl"},{"id":"99d43e98bfd9f53d563dc10659241159","title":"React little by little 1 -  Time Slicing","content":"You may have heard people saying ‚ÄúReact is fast‚Äù as it uses virtual DOM.But is virtual DOM the only thing you can think of when talking about React performance?In fact React has done many things to handle performance issues.\nToday I will talk about Time Slicing.A technique React uses to solve performance bottleneck.\nEvent Loop and CPU bottlenecksEvent LoopModern browsers run a continuous event loop at a certain frequency - e.g. 60Hz (refresh 60 times a second). For smooth and responsive experience, browsers try to complete tasks within each event loop execution, aka a frame.\n\nFor 60Hz refresh rate devices, each execution frame has a budget of 16.66ms (1 second &#x2F; 60).\nCPU bottlenecksWithin such a shoestring budget, browsers have to handle a pipeline of work like this:\n\nIf any step in this pipeline needs more than 16.66ms, no time will be left for the upcoming work in this frame.This means we will not have time for style calculations, layout, paint and compositing, when we spend too much time on JavaScript jobs.When this lasts for 2 or 3 seconds, users will feel your website is slow.\nHow does React avoid this scenario?React sets up an interval for running JavaScript tasks in each frame.When running out of this interval, React will pause its current tasks and give back control to the main thread, letting it perform high priority tasks (painting or user events).After the main thread has finished prioritized jobs, React goes back to where it stopped and continues working.\nAs you may have noticed, the key here is to make React interruptible.\nTime Slicing and Interruptible ReactAssume we have a large application with 500+ components to render.\nWhile rendering these components, how does React ensure responsiveness for keyboard or mouse events?Before React 16, the render phase was synchronize and uninterruptible.The browser therefore would be easily occupied by CPU-hungry tasks,and unable to give prompt responses to user events.Take a look at this video to see what CPU-heavy tasks could be like.\nSo, how did React overcome this?Answer: Time Slicing.\nHere is a picture of time slicing in React (idea of Andrew Clark from the React core team).\n\nInterruptible render phaseAfter version 16, React started using Fiber reconciler to ensure the render phase is interruptible. It breaks down the render phase into time slices so that it can pause current work to run more urgent tasks, like user inputs.As shown in the above picture, time slicing enables browser events to cut in line during the render phase. This helps React to avoid ‚Äúhiccup‚Äù moments.\nUninterruptible commit phaseUnlike the render phase, the commit phase can not be interrupted.You can think of these two like a movie screenplay and a movie on show.When a movie is on (the commit phase), theatres will not suddenly stop playing or change its order of scenes. Just like React will not draw some semi-calculated UI or suddenly stop the commit phase.\nInterruptible Work LoopBefore version 16, React reconciler is implemented by call stack recursion. However, stack Reconciliation will not allow pauses on the running render phase.As mentioned earlier, a high performance render phase is time sliced and interruptible. To implement this, we can change the call stack recursion to conditional while loop recursion:\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\n\nwhile (workInProgress !&#x3D;&#x3D; null &amp;&amp; !shouldYield)\n\n\n\n\n\n\n\n\nThis enables us to stop the workLoop, especially when there is no time left in each frame (shouldYield).  \n\nrequestIdleCallback\n\n\n\n\n\n\n\n\nCheck whether the main thread is idle for running sliced tasks.\n\n\nFiber ReconcilerThis interruptable reconciler is called Fiber reconciler in React.To know more about React Fiber, take a look at this post first: React Fiber Tree.\nReferences[1] Sneak Peek: Beyond React 16, Dan Abramov[1] Build your own React, Rodrigo Pombo[2] Event loop: microtasks and macrotasks, javascript.info[3] Visualization of async rendering and synchronous rendering in React, Andrew Clark[4] Reconciliation, React official documents[5] Rendering Performance, Paul Lewis[6] Frame timing, W3C\n","slug":"time-slicing-react","date":"2022-09-28T22:49:47.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"}]