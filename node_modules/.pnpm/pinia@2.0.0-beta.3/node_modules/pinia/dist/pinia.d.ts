import { App } from 'vue';
import { DebuggerEvent } from 'vue';
import { Plugin as Plugin_2 } from 'vue';
import { Ref } from 'vue';
import { UnwrapRef } from 'vue';

/**
 * Type of an object of Actions
 *
 * @internal
 */
export declare type ActionsTree = Record<string, _Method>;

/**
 * Creates a Pinia instance to be used by the application
 */
export declare function createPinia(): Pinia;

declare type DeepPartial<T> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

/**
 * Creates a `useStore` function that retrieves the store instance
 * @param options - options to define the store
 */
export declare function defineStore<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(options: DefineStoreOptions<Id, S, G, A>): StoreDefinition<Id, S, G, A>;

/**
 * Options parameter of `defineStore()`. Can be extended to augment stores with
 * the plugin API.
 */
export declare interface DefineStoreOptions<Id extends string, S extends StateTree, G extends GettersTree<S>, A> {
    /**
     * Unique string key to identify the store across the application.
     */
    id: Id;
    /**
     * Function to create a fresh state.
     */
    state?: () => S;
    /**
     * Optional object of getters.
     */
    getters?: G & ThisType<UnwrapRef<S> & StoreWithGetters<G> & PiniaCustomProperties>;
    /**
     * Optional object of actions.
     */
    actions?: A & ThisType<A & UnwrapRef<S> & StoreWithState<Id, S, G, A> & StoreWithGetters<G> & PiniaCustomProperties>;
}

/**
 * Generic and type-unsafe version of Store. Doesn't fail on access with
 * strings, making it much easier to write generic functions that do not care
 * about the kind of store that is passed.
 */
export declare type GenericStore<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = StoreWithState<Id, S, G, A> & UnwrapRef<S> & StoreWithGetters<G> & StoreWithActions<A> & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;

/**
 * Type of an object of Getters that infers the argument
 *
 * @internal
 */
export declare type GettersTree<S extends StateTree> = Record<string, ((state: UnwrapRef<S & PiniaCustomStateProperties<S>>) => any) | (() => any)>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component. The values of the object are the actions while the keys are
 * the names of the resulting methods.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     // useCounterStore has two actions named `increment` and `setCount`
 *     ...mapActions(useCounterStore, { moar: 'increment', setIt: 'setCount' })
 *   },
 *
 *   created() {
 *     this.moar()
 *     this.setIt(2)
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object to define new names for the actions
 */
export declare function mapActions<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof A>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapActionsObjectReturn<A, KeyMapper>;

/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   methods: {
 *     // other methods properties
 *     ...mapActions(useCounterStore, ['increment', 'setCount'])
 *   },
 *
 *   created() {
 *     this.increment()
 *     this.setCount(2) // pass arguments as usual
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of action names to map
 */
export declare function mapActions<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof A>): _MapActionsReturn<A>;

/**
 * @internal
 */
export declare type _MapActionsObjectReturn<A, T extends Record<string, keyof A>> = {
    [key in keyof T]: A[T[key]];
};

/**
 * @internal
 */
export declare type _MapActionsReturn<A> = {
    [key in keyof A]: A[key];
};

/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
export declare const mapGetters: typeof mapState;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component. The values of the object are the state properties/getters
 * while the keys are the names of the resulting computed properties.
 * Optionally, you can also pass a custom function that will receive the store
 * as its first argument. Note that while it has access to the component
 * instance via `this`, it won't be typed.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     // useCounterStore has a state property named `count` and a getter `double`
 *     ...mapState(useCounterStore, {
 *       n: 'count',
 *       triple: store => store.n * 3,
 *       // note we can't use an arrow function if we want to use `this`
 *       custom(store) {
 *         return this.someComponentValue + store.n
 *       },
 *       doubleN: 'double'
 *     })
 *   },
 *
 *   created() {
 *     this.n // 2
 *     this.doubleN // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapStateObjectReturn<Id, S, G, A, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapState(useCounterStore, ['count', 'double'])
 *   },
 *
 *   created() {
 *     this.count // 2
 *     this.double // 4
 *   }
 * }
 * ```
 *
 * @param useStore - store to map from
 * @param keys - array of state properties or getters
 */
export declare function mapState<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof S | keyof G>): _MapStateReturn<S, G>;

/**
 * @internal
 */
export declare type _MapStateObjectReturn<Id extends string, S extends StateTree, G extends GettersTree<S>, A, T extends Record<string, keyof S | keyof G | ((store: Store<Id, S, G, A>) => any)>> = {
    [key in keyof T]: () => T[key] extends (store: Store) => infer R ? R : T[key] extends keyof Store<Id, S, G, A> ? Store<Id, S, G, A>[T[key]] : never;
};

/**
 * @internal
 */
export declare type _MapStateReturn<S extends StateTree, G extends GettersTree<S>> = {
    [key in keyof S | keyof G]: () => key extends keyof Store<string, S, G, {}> ? Store<string, S, G, {}>[key] : never;
};

/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
export declare function mapStores<Stores extends any[]>(...stores: [...Stores]): _Spread<Stores>;

/**
 * Interface to allow customizing map helpers. Extend this interface with the
 * following properties:
 *
 * - `suffix`: string. Affects the suffix of `mapStores()`, defaults to `Store`.
 */
export declare interface MapStoresCustomization {
}

/**
 * Same as `mapState()` but creates computed setters as well so the state can be
 * modified. Differently from `mapState()`, only `state` properties can be
 * added.
 *
 * @param useStore - store to map from
 * @param keyMapper - object of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G extends GettersTree<S>, A, KeyMapper extends Record<string, keyof S>>(useStore: StoreDefinition<Id, S, G, A>, keyMapper: KeyMapper): _MapWritableStateObjectReturn<S, KeyMapper>;

/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keys - array of state properties
 */
export declare function mapWritableState<Id extends string, S extends StateTree, G extends GettersTree<S>, A>(useStore: StoreDefinition<Id, S, G, A>, keys: Array<keyof S>): _MapWritableStateReturn<S>;

/**
 * @internal
 */
export declare type _MapWritableStateObjectReturn<S extends StateTree, T extends Record<string, keyof S>> = {
    [key in keyof T]: {
        get: () => S[T[key]];
        set: (value: S[T[key]]) => any;
    };
};

/**
 * @internal
 */
export declare type _MapWritableStateReturn<S extends StateTree> = {
    [key in keyof S]: {
        get: () => S[key];
        set: (value: S[key]) => any;
    };
};

/**
 * Generic type for a function that can infer arguments and return type
 *
 * @internal
 */
export declare type _Method = (...args: any[]) => any;

/**
 * Possible types for SubscriptionCallback
 */
export declare enum MutationType {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    direct = "direct",
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    patchObject = "patch object",
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    patchFunction = "patch function"
}

/**
 * Every application must own its own pinia to be able to create stores
 */
export declare interface Pinia {
    install: Exclude<Plugin_2['install'], undefined>;
    /**
     * root state
     */
    state: Ref<Record<string, StateTree>>;
    /**
     * Adds a store plugin to extend every store
     *
     * @param plugin - store plugin to add
     */
    use(plugin: PiniaStorePlugin): Pinia;
    /**
     * Installed store plugins
     *
     * @internal
     */
    _p: Array<PiniaStorePlugin>;
    /**
     * App linked to this Pinia instance
     *
     * @internal
     */
    _a: App;
}

/**
 * Properties that are added to every store by `pinia.use()`
 */
export declare interface PiniaCustomProperties<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> {
}

/**
 * Properties that are added to every `store.$state` by `pinia.use()`
 */
export declare interface PiniaCustomStateProperties<S extends StateTree = StateTree> {
}

/**
 * Context argument passed to Pinia plugins.
 */
export declare interface PiniaPluginContext<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> {
    /**
     * pinia instance.
     */
    pinia: Pinia;
    /**
     * Current app created with `Vue.createApp()`.
     */
    app: App;
    /**
     * Current store being extended.
     */
    store: Store<Id, S, G, A>;
    /**
     * Current store being extended.
     */
    options: DefineStoreOptions<Id, S, G, A>;
}

/**
 * Plugin to extend every store
 */
export declare interface PiniaStorePlugin {
    /**
     * Plugin to extend every store. Returns an object to extend the store or
     * nothing.
     *
     * @param context - Context
     */
    (context: PiniaPluginContext): Partial<PiniaCustomProperties & PiniaCustomStateProperties> | void;
}

/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
export declare const setActivePinia: (pinia: Pinia | undefined) => Pinia | undefined;

/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you need are using TypeScript.
 *
 * @param suffix - new suffix
 */
export declare function setMapStoreSuffix(suffix: MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : string): void;

/**
 * @internal
 */
export declare type _Spread<A extends readonly any[]> = A extends [infer L, ...infer R] ? _StoreObject<L> & _Spread<R> : unknown;

/**
 * Generic state of a Store
 */
export declare type StateTree = Record<string | number | symbol, any>;

/**
 * Store type to build a store
 */
export declare type Store<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = StoreWithState<Id, StateTree extends S ? {} : S, G, A> & (StateTree extends S ? {} : UnwrapRef<S>) & (GettersTree<S> extends G ? {} : StoreWithGetters<G>) & (ActionsTree extends A ? {} : StoreWithActions<A>) & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;

/**
 * Return type of `defineStore()`. Function that allows instantiating a store.
 */
export declare interface StoreDefinition<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> {
    /**
     * Returns a store, creates it if necessary.
     *
     * @param pinia - Pinia instance to retrieve the store
     */
    (pinia?: Pinia | null | undefined): Store<Id, S, G, A>;
    /**
     * Id of the store. Used by map helpers.
     */
    $id: Id;
}

/**
 * @internal
 */
export declare type _StoreObject<S> = S extends StoreDefinition<infer Ids, infer State, infer Getters, infer Actions> ? {
    [Id in `${Ids}${MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : 'Store'}`]: () => Store<Id extends `${infer RealId}${MapStoresCustomization extends Record<'suffix', string> ? MapStoresCustomization['suffix'] : 'Store'}` ? RealId : string, State, Getters, Actions>;
} : {};

/**
 * Argument of `store.$onAction()`
 */
export declare type StoreOnActionListener<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = (context: StoreOnActionListenerContext<Id, S, G, A>) => void;

/**
 * Context object passed to callbacks of `store.$onAction(context => {})`
 */
export declare type StoreOnActionListenerContext<Id extends string, S extends StateTree, G extends GettersTree<S>, A> = {
    [Name in keyof A]: {
        /**
         * Name of the action
         */
        name: Name;
        /**
         * Store that is invoking the action
         */
        store: Store<Id, S, G, A>;
        /**
         * Parameters passed to the action
         */
        args: A[Name] extends _Method ? Parameters<A[Name]> : unknown[];
        /**
         * Sets up a hook once the action is finished. It receives the return value of
         * the action, if it's a Promise, it will be unwrapped.
         */
        after: (callback: A[Name] extends _Method ? (resolvedReturn: UnwrapPromise<ReturnType<A[Name]>>) => void : () => void) => void;
        /**
         * Sets up a hook if the action fails.
         */
        onError: (callback: (error: unknown) => void) => void;
    };
}[keyof A];

/**
 * Store augmented for actions
 *
 * @internal
 */
export declare type StoreWithActions<A> = {
    [k in keyof A]: A[k] extends (...args: infer P) => infer R ? (...args: P) => R : never;
};

/**
 * Store augmented with getters
 *
 * @internal
 */
export declare type StoreWithGetters<G> = {
    readonly [k in keyof G]: G[k] extends (...args: any[]) => infer R ? R : never;
};

/**
 * Base store with state and functions
 * @internal
 */
export declare interface StoreWithState<Id extends string, S extends StateTree, G extends GettersTree<StateTree> = GettersTree<S>, A = ActionsTree> {
    /**
     * Unique identifier of the store
     */
    $id: Id;
    /**
     * State of the Store. Setting it will replace the whole state.
     */
    $state: UnwrapRef<S> & PiniaCustomStateProperties<S>;
    /**
     * Private property defining the pinia the store is attached to.
     *
     * @internal
     */
    _p: Pinia;
    /**
     * Used by devtools plugin to retrieve getters. Removed in production.
     *
     * @internal
     */
    _getters?: string[];
    /**
     * Used by devtools plugin to retrieve properties added with plugins. Removed in production.
     *
     * @internal
     */
    _customProperties: Set<string>;
    /**
     * Applies a state patch to current state. Allows passing nested values
     *
     * @param partialState - patch to apply to the state
     */
    $patch(partialState: DeepPartial<UnwrapRef<S>>): void;
    /**
     * Group multiple changes into one function. Useful when mutating objects like
     * Sets or arrays and applying an object patch isn't practical, e.g. appending
     * to an array.
     *
     * @param stateMutator - function that mutates `state`, cannot be async
     */
    $patch<F extends (state: UnwrapRef<S>) => void>(stateMutator: ReturnType<F> extends Promise<any> ? never : F): void;
    /**
     * Resets the store to its initial state by building a new state object.
     */
    $reset(): void;
    /**
     * Setups a callback to be called whenever the state changes. It also returns
     * a function to remove the callback. Note than when calling
     * `store.$subscribe()` inside of a component, it will be automatically
     * cleanup up when the component gets unmounted.
     *
     * @param callback - callback passed to the watcher
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>): () => void;
    /**
     * Array of registered action subscriptions.Set without the generics to avoid
     * errors between the generic version of Store and specific stores.
     *
     * @internal
     */
    _as: StoreOnActionListener[];
    /**
     * @alpha Please send feedback at https://github.com/posva/pinia/issues/240
     * Setups a callback to be called every time an action is about to get
     * invoked. The callback receives an object with all the relevant information
     * of the invoked action:
     * - `store`: the store it is invoked on
     * - `name`: The name of the action
     * - `args`: The parameters passed to the action
     *
     * On top of these, it receives two functions that allow setting up a callback
     * once the action finishes or when it fails.
     *
     * It also returns a function to remove the callback. Note than when calling
     * `store.$onAction()` inside of a component, it will be automatically cleanup
     * up when the component gets unmounted.
     *
     * @example
     *
     *```js
     *store.$onAction(({ after, onError }) => {
     *  // Here you could share variables between all of the hooks as well as
     *  // setting up watchers and clean them up
     *  after((resolvedValue) => {
     *    // can be used to cleanup side effects
     * .  // `resolvedValue` is the value returned by the action, if it's a
     * .  // Promise, it will be the resolved value instead of the Promise
     *  })
     *  onError((error) => {
     *    // can be used to pass up errors
     *  })
     *})
     *```
     *
     * @param callback - callback called before every action
     * @returns function that removes the watcher
     */
    $onAction(callback: StoreOnActionListener<Id, S, G, A>): () => void;
}

/**
 * Callback of a subscription
 */
export declare type SubscriptionCallback<S> = (
/**
 * Object with information relative to the store mutation that triggered the
 * subscription.
 */
mutation: SubscriptionCallbackMutation<S>, 
/**
 * State of the store when the subscription is triggered. Same as
 * `store.$state`.
 */
state: UnwrapRef<S>) => void;

/**
 * Context object passed to a subscription callback.
 */
export declare type SubscriptionCallbackMutation<S> = SubscriptionCallbackMutationDirect | SubscriptionCallbackMutationPatchObject<S> | SubscriptionCallbackMutationPatchFunction;

/**
 * Base type for the context passed to a subscription callback.
 *
 * @internal
 */
export declare interface _SubscriptionCallbackMutationBase {
    /**
     * Type of the mutation.
     */
    type: MutationType;
    /**
     * `id` of the store doing the mutation.
     */
    storeId: string;
}

/**
 * Context passed to a subscription callback when directly mutating the state of
 * a store with `store.someState = newValue` or `store.$state.someState =
 * newValue`.
 */
export declare interface SubscriptionCallbackMutationDirect extends _SubscriptionCallbackMutationBase {
    type: MutationType.direct;
    /**
     * DEV ONLY. Different mutation calls.
     */
    events: DebuggerEvent;
}

/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with a function.
 */
export declare interface SubscriptionCallbackMutationPatchFunction extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchFunction;
    /**
     * DEV ONLY. Array of all the mutations done inside of the callback.
     */
    events: DebuggerEvent[];
}

/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with an object.
 */
export declare interface SubscriptionCallbackMutationPatchObject<S> extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchObject;
    /**
     * DEV ONLY. Array for patch calls.
     */
    events: DebuggerEvent[];
    /**
     * Object passed to `store.$patch()`.
     */
    payload: DeepPartial<S>;
}

declare type UnwrapPromise<T> = T extends Promise<infer V> ? V : T;

export { }
