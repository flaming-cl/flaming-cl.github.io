/*!
  * pinia v2.0.0-beta.3
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var devtoolsApi = require('@vue/devtools-api');

/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia
 */
const getActivePinia = () => {
    if ((process.env.NODE_ENV !== 'production') && !activePinia) {
        vue.warn(`[üçç]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\n\n` +
            `const pinia = createPinia()\n` +
            `app.use(pinia)\n\n` +
            `This will fail in production.`);
    }
    return activePinia;
};
/**
 * Map of stores based on a Pinia instance. Allows setting and retrieving stores
 * for the current running application (with its pinia).
 */
const storesMap = new WeakMap();
const piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
/**
 * Possible types for SubscriptionCallback
 */
exports.MutationType = void 0;
(function (MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    MutationType["patchFunction"] = "patch function";
    // maybe reset? for $state = {} and $reset
})(exports.MutationType || (exports.MutationType = {}));

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var FileSaver_min = {exports: {}};

(function (module, exports) {
(function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open("GET",a),d.responseType="blob",d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error("could not download file");},d.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open("","_blank"),g&&(g.document.title=g.document.body.innerText="downloading..."),"string"==typeof b)return c(b,d,e);var h="application/octet-stream"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&"undefined"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else {var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


}(FileSaver_min));

/**
 * Shows a toast or console.log
 *
 * @param message - message to log
 * @param type - different color of the tooltip
 */
function toastMessage(message, type) {
    const piniaMessage = 'üçç ' + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    }
    else if (type === 'error') {
        console.error(piniaMessage);
    }
    else if (type === 'warn') {
        console.warn(piniaMessage);
    }
    else {
        console.log(piniaMessage);
    }
}
function isPinia(o) {
    return '_a' in o && 'install' in o;
}

function checkClipboardAccess() {
    if (!('clipboard' in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');
        return true;
    }
}
function checkNotFocusedError(error) {
    if (error.message.toLowerCase().includes('document is not focused')) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', 'warn');
        return true;
    }
}
async function actionGlobalCopyState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage('Global state copied to clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalPasteState(pinia) {
    if (checkClipboardAccess())
        return;
    try {
        pinia.state.value = JSON.parse(await navigator.clipboard.readText());
        toastMessage('Global state pasted from clipboard.');
    }
    catch (error) {
        if (checkNotFocusedError(error))
            return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');
        console.error(error);
    }
}
async function actionGlobalSaveState(pinia) {
    try {
        FileSaver_min.exports.saveAs(new Blob([JSON.stringify(pinia.state.value)], {
            type: 'text/plain;charset=utf-8',
        }), 'pinia-state.json');
    }
    catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}
let fileInput;
function getFileOpener() {
    if (!fileInput) {
        fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
    }
    function openFile() {
        return new Promise((resolve, reject) => {
            fileInput.onchange = async () => {
                const files = fileInput.files;
                if (!files)
                    return resolve(null);
                const file = files.item(0);
                if (!file)
                    return resolve(null);
                return resolve({ text: await file.text(), file });
            };
            fileInput.oncancel = () => resolve(null);
            fileInput.click();
        });
    }
    return openFile;
}
async function actionGlobalOpenStateFile(pinia) {
    try {
        const open = await getFileOpener();
        const result = await open();
        if (!result)
            return;
        const { text, file } = result;
        pinia.state.value = JSON.parse(text);
        toastMessage(`Global state imported from "${file.name}".`);
    }
    catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');
        console.error(error);
    }
}

function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
const PINIA_ROOT_LABEL = 'üçç Pinia (root)';
const PINIA_ROOT_ID = '_root';
function formatStoreForInspectorTree(store) {
    return '$id' in store
        ? {
            id: store.$id,
            label: store.$id,
        }
        : {
            id: PINIA_ROOT_ID,
            label: PINIA_ROOT_LABEL,
        };
}
function formatStoreForInspectorState(store) {
    if (isPinia(store)) {
        const state = {
            state: Object.keys(store.state.value).map((storeId) => ({
                editable: true,
                key: storeId,
                value: store.state.value[storeId],
            })),
        };
        // TODO: use this version when possible
        // Object.keys(store.state.value).forEach((storeId) => {
        //   const currentState = store.state.value[storeId]
        //   state[storeId] = Object.keys(currentState).map((key) => ({
        //     // is not possible to made editable because no way to get the storeId in
        //     // edit inspector state callback
        //     editable: false,
        //     key,
        //     value: currentState[key],
        //   }))
        // })
        return state;
    }
    const state = {
        state: Object.keys(store.$state).map((key) => ({
            editable: true,
            key,
            // @ts-expect-error
            value: store.$state[key],
        })),
    };
    // avoid adding empty getters
    if (store._getters && store._getters.length) {
        state.getters = store._getters.map((getterName) => ({
            editable: false,
            key: getterName,
            // @ts-expect-error
            value: store[getterName],
        }));
    }
    if (store._customProperties.size) {
        state.customProperties = Array.from(store._customProperties).map((key) => ({
            editable: true,
            key,
            // @ts-expect-error
            value: store[key],
        }));
    }
    return state;
}
function formatEventData(events) {
    if (!events)
        return {};
    if (Array.isArray(events)) {
        // TODO: handle add and delete for arrays and objects
        return events.reduce((data, event) => {
            data.keys.push(event.key);
            data.operations.push(event.type);
            data.oldValue[event.key] = event.oldValue;
            data.newValue[event.key] = event.newValue;
            return data;
        }, {
            oldValue: {},
            keys: [],
            operations: [],
            newValue: {},
        });
    }
    else {
        return {
            operation: formatDisplay(events.type),
            key: formatDisplay(events.key),
            oldValue: events.oldValue,
            newValue: events.newValue,
        };
    }
}
function formatMutationType(type) {
    switch (type) {
        case exports.MutationType.direct:
            return 'mutation';
        case exports.MutationType.patchFunction:
            return '$patch';
        case exports.MutationType.patchObject:
            return '$patch';
        default:
            return 'unknown';
    }
}

/**
 * Registered stores used for devtools.
 */
const registeredStores = /*#__PURE__*/ new Map();
let isAlreadyInstalled;
// timeline can be paused when directly changing the state
let isTimelineActive = true;
const componentStateTypes = [];
const MUTATIONS_LAYER_ID = 'pinia:mutations';
const INSPECTOR_ID = 'pinia';
function addDevtools(app, store) {
    // TODO: we probably need to ensure the latest version of the store is kept:
    // without effectScope, multiple stores will be created and will have a
    // limited lifespan for getters.
    // add a dev only variable that is removed in unmounted and replace the store
    let hasSubscribed = true;
    const storeType = 'üçç ' + store.$id;
    if (!registeredStores.has(store.$id)) {
        registeredStores.set(store.$id, store);
        componentStateTypes.push(storeType);
        hasSubscribed = false;
    }
    devtoolsApi.setupDevtoolsPlugin({
        id: 'dev.esm.pinia',
        label: 'Pinia üçç',
        logo: 'https://pinia.esm.dev/logo.svg',
        packageName: 'pinia',
        homepage: 'https://pinia.esm.dev',
        componentStateTypes,
        app,
    }, (api) => {
        if (!isAlreadyInstalled) {
            api.addTimelineLayer({
                id: MUTATIONS_LAYER_ID,
                label: `Pinia üçç`,
                color: 0xe5df88,
            });
            api.addInspector({
                id: INSPECTOR_ID,
                label: 'Pinia üçç',
                icon: 'storage',
                treeFilterPlaceholder: 'Search stores',
                actions: [
                    {
                        icon: 'content_copy',
                        action: () => {
                            actionGlobalCopyState(store._p);
                        },
                        tooltip: 'Serialize and copy the state',
                    },
                    {
                        icon: 'content_paste',
                        action: async () => {
                            await actionGlobalPasteState(store._p);
                            api.sendInspectorTree(INSPECTOR_ID);
                            api.sendInspectorState(INSPECTOR_ID);
                        },
                        tooltip: 'Replace the state with the content of your clipboard',
                    },
                    {
                        icon: 'save',
                        action: () => {
                            actionGlobalSaveState(store._p);
                        },
                        tooltip: 'Save the state as a JSON file',
                    },
                    {
                        icon: 'folder_open',
                        action: async () => {
                            await actionGlobalOpenStateFile(store._p);
                            api.sendInspectorTree(INSPECTOR_ID);
                            api.sendInspectorState(INSPECTOR_ID);
                        },
                        tooltip: 'Import the state from a JSON file',
                    },
                ],
            });
            api.on.inspectComponent((payload, ctx) => {
                const proxy = (payload.componentInstance &&
                    payload.componentInstance.proxy);
                if (proxy && proxy._pStores) {
                    const piniaStores = payload.componentInstance.proxy._pStores;
                    Object.values(piniaStores).forEach((store) => {
                        payload.instanceData.state.push({
                            type: storeType,
                            key: 'state',
                            editable: true,
                            value: store.$state,
                        });
                        if (store._getters && store._getters.length) {
                            payload.instanceData.state.push({
                                type: storeType,
                                key: 'getters',
                                editable: false,
                                value: store._getters.reduce((getters, key) => {
                                    // @ts-expect-error
                                    getters[key] = store[key];
                                    return getters;
                                }, {}),
                            });
                        }
                    });
                }
            });
            api.on.getInspectorTree((payload) => {
                if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                    let stores = [store._p];
                    stores = stores.concat(Array.from(registeredStores.values()));
                    payload.rootNodes = (payload.filter
                        ? stores.filter((store) => '$id' in store
                            ? store.$id
                                .toLowerCase()
                                .includes(payload.filter.toLowerCase())
                            : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))
                        : stores).map(formatStoreForInspectorTree);
                }
            });
            api.on.getInspectorState((payload) => {
                if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                    const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                        ? store._p
                        : registeredStores.get(payload.nodeId);
                    if (!inspectedStore) {
                        return toastMessage(`store "${payload.nodeId}" not found`, 'error');
                    }
                    if (inspectedStore) {
                        payload.state = formatStoreForInspectorState(inspectedStore);
                    }
                }
            });
            api.on.editInspectorState((payload, ctx) => {
                if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
                    const inspectedStore = payload.nodeId === PINIA_ROOT_ID
                        ? store._p
                        : registeredStores.get(payload.nodeId);
                    if (!inspectedStore) {
                        return toastMessage(`store "${payload.nodeId}" not found`, 'error');
                    }
                    const { path } = payload;
                    if (!isPinia(store)) {
                        // access only the state
                        if (path.length !== 1 ||
                            !store._customProperties.has(path[0]) ||
                            path[0] in store.$state) {
                            path.unshift('$state');
                        }
                    }
                    else {
                        path.unshift('state', 'value');
                    }
                    isTimelineActive = false;
                    payload.set(inspectedStore, path, payload.state.value);
                    isTimelineActive = true;
                }
            });
            api.on.editComponentState((payload) => {
                if (payload.type.startsWith('üçç')) {
                    const storeId = payload.type.replace(/^üçç\s*/, '');
                    const store = registeredStores.get(storeId);
                    if (!store) {
                        return toastMessage(`store "${storeId}" not found`, 'error');
                    }
                    const { path } = payload;
                    if (path[0] !== 'state') {
                        return toastMessage(`Invalid path for store "${storeId}":\n${path}\nOnly state can be modified.`);
                    }
                    // rewrite the first entry to be able to directly set the state as
                    // well as any other path
                    path[0] = '$state';
                    isTimelineActive = false;
                    payload.set(store, path, payload.state.value);
                    isTimelineActive = true;
                }
            });
            isAlreadyInstalled = true;
        }
        else {
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
        }
        // avoid subscribing to mutations and actions twice
        if (hasSubscribed)
            return;
        store.$onAction(({ after, onError, name, args, store }) => {
            const groupId = runningActionId++;
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                    time: Date.now(),
                    title: 'üõ´ ' + name,
                    subtitle: 'start',
                    data: {
                        action: formatDisplay(name),
                        args,
                    },
                    groupId,
                },
            });
            after((result) => {
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: Date.now(),
                        title: 'üõ¨ ' + name,
                        subtitle: 'end',
                        data: {
                            action: formatDisplay(name),
                            args,
                            result,
                        },
                        groupId,
                    },
                });
            });
            onError((error) => {
                api.addTimelineEvent({
                    layerId: MUTATIONS_LAYER_ID,
                    event: {
                        time: Date.now(),
                        logType: 'error',
                        title: 'üí• ' + name,
                        subtitle: 'end',
                        data: {
                            action: formatDisplay(name),
                            args,
                            error,
                        },
                        groupId,
                    },
                });
            });
        });
        store.$subscribe(({ events, type }, state) => {
            if (!isTimelineActive)
                return;
            // rootStore.state[store.id] = state
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            const eventData = {
                time: Date.now(),
                title: formatMutationType(type),
                data: formatEventData(events),
                groupId: activeAction,
            };
            // reset for the next mutation
            activeAction = undefined;
            if (type === exports.MutationType.patchFunction) {
                eventData.subtitle = '‚§µÔ∏è';
            }
            else if (type === exports.MutationType.patchObject) {
                eventData.subtitle = 'üß©';
            }
            else if (events && !Array.isArray(events)) {
                eventData.subtitle = events.type;
            }
            if (events) {
                eventData.data['rawEvent(s)'] = {
                    _custom: {
                        display: 'DebuggerEvent',
                        type: 'object',
                        tooltip: 'raw DebuggerEvent[]',
                        value: events,
                    },
                };
            }
            api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: eventData,
            });
        });
        // trigger an update so it can display new registered stores
        // @ts-ignore
        api.notifyComponentUpdate();
        toastMessage(`"${store.$id}" store installed`);
    });
}
let runningActionId = 0;
let activeAction;
/**
 * pinia.use(devtoolsPlugin)
 */
function devtoolsPlugin({ app, store, options, pinia }) {
    const wrappedActions = {};
    // original actions of the store as they are given by pinia. We are going to override them
    const actions = Object.keys(options.actions || {}).reduce((storeActions, actionName) => {
        // @ts-expect-error
        storeActions[actionName] = store[actionName];
        return storeActions;
    }, {});
    for (const actionName in actions) {
        // @ts-expect-error
        wrappedActions[actionName] = function () {
            setActivePinia(pinia);
            // the running action id is incremented in a before action hook
            const _actionId = runningActionId;
            const trackedStore = new Proxy(store, {
                get(...args) {
                    activeAction = _actionId;
                    return Reflect.get(...args);
                },
                set(...args) {
                    activeAction = _actionId;
                    return Reflect.set(...args);
                },
            });
            return actions[actionName].apply(trackedStore, arguments);
        };
    }
    addDevtools(app, 
    // @ts-expect-error: FIXME: if possible...
    store);
    // avoid returning to not display them in devtools
    Object.assign(store, wrappedActions);
}

const IS_CLIENT = typeof window !== 'undefined';

/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = vue.ref({});
    let localApp;
    let _p = [];
    // plugins added before calling app.use(pinia)
    const toBeInstalled = [];
    const pinia = vue.markRaw({
        install(app) {
            pinia._a = localApp = app;
            app.provide(piniaSymbol, pinia);
            app.config.globalProperties.$pinia = pinia;
            if (IS_CLIENT) {
                // this allows calling useStore() outside of a component setup after
                // installing pinia's plugin
                setActivePinia(pinia);
            }
            toBeInstalled.forEach((plugin) => _p.push(plugin));
        },
        use(plugin) {
            if (!localApp) {
                toBeInstalled.push(plugin);
            }
            else {
                _p.push(plugin);
            }
            return this;
        },
        _p,
        // it's actually undefined here
        _a: localApp,
        state,
    });
    // pinia devtools rely on dev only features so they cannot be forced unless
    // the dev build of Vue is used
    if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {
        pinia.use(devtoolsPlugin);
    }
    return pinia;
}

function innerPatch(target, patchToApply) {
    // TODO: get all keys like symbols as well
    for (const key in patchToApply) {
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            !vue.isRef(subPatch) &&
            !vue.isReactive(subPatch)) {
            target[key] = innerPatch(targetValue, subPatch);
        }
        else {
            // @ts-ignore
            target[key] = subPatch;
        }
    }
    return target;
}
const { assign } = Object;
/**
 * Create an object of computed properties referring to
 *
 * @param rootStateRef - pinia.state
 * @param id - unique name
 */
function computedFromState(rootStateRef, id) {
    // let asComputed = computed<T>()
    const reactiveObject = {};
    const state = rootStateRef.value[id];
    for (const key in state) {
        // @ts-expect-error: the key matches
        reactiveObject[key] = vue.computed({
            get: () => rootStateRef.value[id][key],
            set: (value) => (rootStateRef.value[id][key] = value),
        });
    }
    return reactiveObject;
}
/**
 * Creates a store with its state object. This is meant to be augmented with getters and actions
 *
 * @param id - unique identifier of the store, like a name. eg: main, cart, user
 * @param buildState - function to build the initial state
 * @param initialState - initial state applied to the store, Must be correctly typed to infer typings
 */
function initStore($id, buildState = () => ({}), initialState) {
    const pinia = getActivePinia();
    pinia.state.value[$id] = initialState || buildState();
    // const state: Ref<S> = toRef(_p.state.value, $id)
    let isListening = true;
    let subscriptions = vue.markRaw([]);
    let actionSubscriptions = vue.markRaw([]);
    let debuggerEvents;
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = false;
        // reset the debugger events since patches are sync
        /* istanbul ignore else */
        if ((process.env.NODE_ENV !== 'production')) {
            debuggerEvents = [];
        }
        if (typeof partialStateOrMutator === 'function') {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: exports.MutationType.patchFunction,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        else {
            innerPatch(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: exports.MutationType.patchObject,
                payload: partialStateOrMutator,
                storeId: $id,
                events: debuggerEvents,
            };
        }
        isListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        subscriptions.forEach((callback) => {
            callback(subscriptionMutation, pinia.state.value[$id]);
        });
    }
    function $subscribe(callback) {
        subscriptions.push(callback);
        // watch here to link the subscription to the current active instance
        // e.g. inside the setup of a component
        const options = { deep: true, flush: 'sync' };
        /* istanbul ignore else */
        if ((process.env.NODE_ENV !== 'production')) {
            options.onTrigger = (event) => {
                if (isListening) {
                    debuggerEvents = event;
                }
                else {
                    // let patch send all the events together later
                    /* istanbul ignore else */
                    if (Array.isArray(debuggerEvents)) {
                        debuggerEvents.push(event);
                    }
                    else {
                        console.error('üçç debuggerEvents should be an array. This is most likely an internal Pinia bug.');
                    }
                }
            };
        }
        const stopWatcher = vue.watch(() => pinia.state.value[$id], (state, oldState) => {
            if (isListening) {
                callback({
                    storeId: $id,
                    type: exports.MutationType.direct,
                    events: debuggerEvents,
                }, state);
            }
        }, options);
        const removeSubscription = () => {
            const idx = subscriptions.indexOf(callback);
            if (idx > -1) {
                subscriptions.splice(idx, 1);
                stopWatcher();
            }
        };
        if (vue.getCurrentInstance()) {
            vue.onUnmounted(removeSubscription);
        }
        return removeSubscription;
    }
    function $onAction(callback) {
        actionSubscriptions.push(callback);
        const removeSubscription = () => {
            const idx = actionSubscriptions.indexOf(callback);
            if (idx > -1) {
                actionSubscriptions.splice(idx, 1);
            }
        };
        if (vue.getCurrentInstance()) {
            vue.onUnmounted(removeSubscription);
        }
        return removeSubscription;
    }
    function $reset() {
        pinia.state.value[$id] = buildState();
    }
    const storeWithState = {
        $id,
        _p: pinia,
        _as: actionSubscriptions,
        // $state is added underneath
        $patch,
        $subscribe,
        $onAction,
        $reset,
    };
    const injectionSymbol = (process.env.NODE_ENV !== 'production')
        ? Symbol(`PiniaStore(${$id})`)
        : /* istanbul ignore next */
            Symbol();
    return [
        storeWithState,
        {
            get: () => pinia.state.value[$id],
            set: (newState) => {
                isListening = false;
                pinia.state.value[$id] = newState;
                isListening = true;
            },
        },
        injectionSymbol,
    ];
}
const noop = () => { };
/**
 * Creates a store bound to the lifespan of where the function is called. This
 * means creating the store inside of a component's setup will bound it to the
 * lifespan of that component while creating it outside of a component will
 * create an ever living store
 *
 * @param partialStore - store with state returned by initStore
 * @param descriptor - descriptor to setup $state property
 * @param $id - unique name of the store
 * @param getters - getters of the store
 * @param actions - actions of the store
 */
function buildStoreToUse(partialStore, descriptor, $id, getters = {}, actions = {}, options) {
    const pinia = getActivePinia();
    const computedGetters = {};
    for (const getterName in getters) {
        // @ts-ignore: it's only readonly for the users
        computedGetters[getterName] = vue.computed(() => {
            setActivePinia(pinia);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            // @ts-expect-error: the argument count is correct
            return getters[getterName].call(store, store);
        });
    }
    const wrappedActions = {};
    for (const actionName in actions) {
        wrappedActions[actionName] = function () {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const localStore = this || store;
            let afterCallback = noop;
            let onErrorCallback = noop;
            function after(callback) {
                afterCallback = callback;
            }
            function onError(callback) {
                onErrorCallback = callback;
            }
            partialStore._as.forEach((callback) => {
                // @ts-expect-error
                callback({ args, name: actionName, store: localStore, after, onError });
            });
            let ret;
            try {
                ret = actions[actionName].apply(localStore, args);
                Promise.resolve(ret).then(afterCallback).catch(onErrorCallback);
            }
            catch (error) {
                onErrorCallback(error);
                throw error;
            }
            return ret;
        };
    }
    const store = vue.reactive(assign((process.env.NODE_ENV !== 'production') && IS_CLIENT
        ? // devtools custom properties
            {
                _customProperties: vue.markRaw(new Set()),
            }
        : {}, partialStore, 
    // using this means no new properties can be added as state
    computedFromState(pinia.state, $id), computedGetters, wrappedActions));
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', descriptor);
    // add getters for devtools
    if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {
        store._getters = vue.markRaw(Object.keys(getters));
    }
    // apply all plugins
    pinia._p.forEach((extender) => {
        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {
            // @ts-expect-error: conflict between A and ActionsTree
            const extensions = extender({ store, app: pinia._a, pinia, options });
            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
            assign(store, extensions);
        }
        else {
            // @ts-expect-error: conflict between A and ActionsTree
            assign(store, extender({ store, app: pinia._a, pinia, options }));
        }
    });
    return store;
}
/**
 * Creates a `useStore` function that retrieves the store instance
 * @param options - options to define the store
 */
function defineStore(options) {
    const { id, state, getters, actions } = options;
    function useStore(pinia) {
        const currentInstance = vue.getCurrentInstance();
        // only run provide when pinia hasn't been manually passed
        const shouldProvide = currentInstance && !pinia;
        // avoid injecting if `useStore` when not possible
        pinia = pinia || (currentInstance && vue.inject(piniaSymbol));
        if (pinia)
            setActivePinia(pinia);
        // TODO: worth warning on server if no piniaKey as it can leak data
        pinia = getActivePinia();
        let stores = storesMap.get(pinia);
        if (!stores)
            storesMap.set(pinia, (stores = new Map()));
        let storeAndDescriptor = stores.get(id);
        let store;
        if (!storeAndDescriptor) {
            storeAndDescriptor = initStore(id, state, pinia.state.value[id]);
            // @ts-expect-error: annoying to type
            stores.set(id, storeAndDescriptor);
            store = buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options);
            // allow children to reuse this store instance to avoid creating a new
            // store for each child
            if (shouldProvide) {
                vue.provide(storeAndDescriptor[2], store);
            }
        }
        else {
            store =
                (currentInstance && vue.inject(storeAndDescriptor[2], null)) ||
                    buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options);
        }
        // save stores in instances to access them devtools
        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT && currentInstance && currentInstance.proxy) {
            const vm = currentInstance.proxy;
            const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});
            // @ts-expect-error: still can't cast Store with generics to Store
            cache[store.$id] = store;
        }
        return store;
    }
    // needed by map helpers
    useStore.$id = id;
    return useStore;
}

function getCachedStore(vm, useStore) {
    const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});
    const id = useStore.$id;
    return (cache[id] ||
        (cache[id] = useStore(vm.$pinia)));
}
let mapStoreSuffix = 'Store';
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you need are using TypeScript.
 *
 * @param suffix - new suffix
 */
function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
function mapStores(...stores) {
    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {
        console.warn(`[üçç]: Directly pass all stores to "mapStores()" without putting them in an array:\n` +
            `Replace\n` +
            `\tmapStores([useAuthStore, useCartStore])\n` +
            `with\n` +
            `\tmapStores(useAuthStore, useCartStore)\n` +
            `This will fail in production if not fixed.`);
        stores = stores[0];
    }
    return stores.reduce((reduced, useStore) => {
        // @ts-ignore: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function () {
            return getCachedStore(this, useStore);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = function () {
                // @ts-expect-error
                return getCachedStore(this, useStore)[key];
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            reduced[key] = function () {
                const store = getCachedStore(this, useStore);
                const storeKey = keysOrMapper[key];
                // for some reason TS is unable to infer the type of storeKey to be a
                // function
                return typeof storeKey === 'function'
                    ? storeKey.call(this, store)
                    : store[storeKey];
            };
            return reduced;
        }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
const mapGetters = mapState;
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error
                return getCachedStore(this, useStore)[key](...args);
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error
                return getCachedStore(this, useStore)[keysOrMapper[key]](...args);
            };
            return reduced;
        }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-ignore
            reduced[key] = {
                get() {
                    // @ts-expect-error
                    return getCachedStore(this, useStore)[key];
                },
                set(value) {
                    // it's easier to type it here as any
                    // @ts-expect-error
                    return (getCachedStore(this, useStore)[key] = value);
                },
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-ignore
            reduced[key] = {
                get() {
                    // @ts-expect-error
                    return getCachedStore(this, useStore)[keysOrMapper[key]];
                },
                set(value) {
                    // it's easier to type it here as any
                    // @ts-expect-error
                    return (getCachedStore(this, useStore)[keysOrMapper[key]] =
                        value);
                },
            };
            return reduced;
        }, {});
}

exports.createPinia = createPinia;
exports.defineStore = defineStore;
exports.mapActions = mapActions;
exports.mapGetters = mapGetters;
exports.mapState = mapState;
exports.mapStores = mapStores;
exports.mapWritableState = mapWritableState;
exports.setActivePinia = setActivePinia;
exports.setMapStoreSuffix = setMapStoreSuffix;
