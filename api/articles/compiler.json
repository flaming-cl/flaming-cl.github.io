{"title":"CS143 Compiler - Basic concepts","uid":"209a99b3228c3d6a24c530e39b14fe15","slug":"compiler","date":"2023-05-27T20:12:38.000Z","updated":"2023-05-27T21:31:12.271Z","comments":true,"path":"api/articles/compiler.json","keywords":null,"cover":null,"content":"<h3 id=\"1-Lexical-Analysis\"><a href=\"#1-Lexical-Analysis\" class=\"headerlink\" title=\"1. Lexical Analysis\"></a>1. Lexical Analysis</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>This term comes from “lexicon”. In linguistics, a lexicon refers to the vocabulary of a language, including words and phrases. </p></blockquote>\n<p>In a compiler, the task of lexical analysis is to break down the source code into a series of “tokens”, which can be considered the vocabulary of the programming language. </p>\n<h4 id=\"Why-we-don’t-call-this-phase-cutting-or-chopping\"><a href=\"#Why-we-don’t-call-this-phase-cutting-or-chopping\" class=\"headerlink\" title=\"Why we don’t call this phase cutting or chopping?\"></a>Why we don’t call this phase cutting or chopping?</h4><p>This process is not simply “cutting”, as it involves identifying and classifying various elements in the source code, such as keywords, identifiers, operators, etc.</p>\n<h3 id=\"2-Parsing\"><a href=\"#2-Parsing\" class=\"headerlink\" title=\"2. Parsing\"></a>2. Parsing</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>This term comes from the linguistic term “parse”, which means to analyze the grammatical structure of a sentence. </p></blockquote>\n<p>In a compiler, the task of parsing is to construct the grammatical structure of the source code based on a series of tokens, usually represented as a parse tree or abstract syntax tree. </p>\n<h4 id=\"Why-we-don’t-call-it-assembling\"><a href=\"#Why-we-don’t-call-it-assembling\" class=\"headerlink\" title=\"Why we don’t call it assembling?\"></a>Why we don’t call it assembling?</h4><p>This process is not simply “assembling”, as it involves determining the relationships between tokens based on the grammatical rules of the programming language.</p>\n<h3 id=\"3-Semantic-Analysis\"><a href=\"#3-Semantic-Analysis\" class=\"headerlink\" title=\"3. Semantic Analysis\"></a>3. Semantic Analysis</h3><p>After understanding the sentence structure, the next step is to try to understand the meaning of what has been written.<br>This is hard and compilers can only do very limited kinds of semantic analysis. They generally try to catch inconsistencies in the program.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Jack said Jerry left his assignment at home</p></blockquote>\n<p>Do you know whose assignment Jack was talking about?<br>Yes, in English or any other language, we experience ambiguity. But programming languages do not have that much tolerance as human languages do. So we need to do semantic analysis to ensure that the meaning of each statement in the program is clear and unambiguous. </p>\n<h4 id=\"Example-Type-check\"><a href=\"#Example-Type-check\" class=\"headerlink\" title=\"Example: Type check\"></a>Example: Type check</h4><p>This involves checking for type mismatches, ensuring that variables are declared before they are used, checking that functions are called with the correct number of arguments, and so on.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>int x &#x3D; “hello”;</p></blockquote>\n<p>This is a type mismatch and the compiler will throw an error. The compiler, during semantic analysis, will catch this inconsistency, because an integer variable cannot be assigned a string value.</p>\n<h3 id=\"4-Optimization\"><a href=\"#4-Optimization\" class=\"headerlink\" title=\"4. Optimization\"></a>4. Optimization</h3><p>The fourth compiler phase, optimization, is a bit like editing. The goal is to modify the program so that it uses less of some resource, such as time, space, power, etc.</p>\n<p>For example, the text uses the phrase “but a little bit like ending” and its shorter version “but akin to editing” as an example of optimization in English. </p>\n<p>In the context of a compiler, an example rule that says <code>X = Y * 0</code>, is the same as <code>X = 0</code> is used to illustrate the kind of optimizations a compiler might do.</p>\n<h3 id=\"5-Code-Generation\"><a href=\"#5-Code-Generation\" class=\"headerlink\" title=\"5. Code Generation\"></a>5. Code Generation</h3><p>The last compiler phase is code generation, often referred to as Code Gen. It involves translating the high-level program into some other language, such as assembly code.</p>\n<p>Using human languages as an analogy, a human translator might translate English into French, a compiler will translate a high-level program into assembly code.</p>\n","feature":true,"text":"1. Lexical Analysis This term comes from “lexicon”. In linguistics, a lexicon refers to the vocabulary of a language, including words and ph...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"compiler","slug":"compiler","count":1,"path":"api/tags/compiler.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Lexical-Analysis\"><span class=\"toc-text\">1. Lexical Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Why-we-don%E2%80%99t-call-this-phase-cutting-or-chopping\"><span class=\"toc-text\">Why we don’t call this phase cutting or chopping?</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Parsing\"><span class=\"toc-text\">2. Parsing</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Why-we-don%E2%80%99t-call-it-assembling\"><span class=\"toc-text\">Why we don’t call it assembling?</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Semantic-Analysis\"><span class=\"toc-text\">3. Semantic Analysis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Example-Type-check\"><span class=\"toc-text\">Example: Type check</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Optimization\"><span class=\"toc-text\">4. Optimization</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Code-Generation\"><span class=\"toc-text\">5. Code Generation</span></a></li></ol>","author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"TypeScript Function Overloads","uid":"e8aa6c77cc743a25eb58a8f5670b685f","slug":"ts-function-overload","date":"2023-07-03T13:42:34.000Z","updated":"2023-07-30T00:01:52.688Z","comments":true,"path":"api/articles/ts-function-overload.json","keywords":null,"cover":[],"text":"Today I’ve come across something that seems baffling in Vuetify’s source code, genericComponent: a function with the same name declared mult...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","count":1,"path":"api/tags/TypeScript.json"}],"author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Data Abstraction from SICP","uid":"663764549142bb4876ce625b417bf9d8","slug":"SICP-2-data-abstraction","date":"2023-03-28T00:14:53.000Z","updated":"2023-04-04T15:21:09.733Z","comments":true,"path":"api/articles/SICP-2-data-abstraction.json","keywords":null,"cover":[],"text":"Data AbstractionIn functional programming, data abstraction is a technique that uses functions to hide the details of data structures, and p...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Functional-Programming","slug":"Functional-Programming","count":2,"path":"api/tags/Functional-Programming.json"}],"author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}