{"title":"Is setState asynchronous?","uid":"d7e769e271f05380381ff271e09b897f","slug":"async-setState","date":"2023-02-07T20:07:27.000Z","updated":"2023-03-03T20:12:22.744Z","comments":true,"path":"api/articles/async-setState.json","keywords":null,"cover":null,"content":"<p>Whether setState is synchronous or asynchronous has become a cliché these days.   </p>\n<p>However, as React is constantly evolving, a frontend programmer’s answer to this question can still demonstrate some deep understanding of the framework.</p>\n<p>Today, let’s gain a deeper understanding of some implementation mechanisms behind React.</p>\n<h2 id=\"Ideas-of-this-article\"><a href=\"#Ideas-of-this-article\" class=\"headerlink\" title=\"Ideas of this article\"></a>Ideas of this article</h2><p>Although <code>setState()</code> is not inherently asynchronous, React has designed it to behave like an asynchronous function for certain reasons. This article will:</p>\n<ul>\n<li>Summarize why <code>setState()</code> behaves like an asynchronous function.</li>\n<li>Explore the reasons why synchronous <code>setState()</code> can behave asynchronously.</li>\n<li>Clarify whether <code>setState()</code> behaves like a microtask or a macrotask.</li>\n</ul>\n<h2 id=\"Why-setState-act-like-an-async-function\"><a href=\"#Why-setState-act-like-an-async-function\" class=\"headerlink\" title=\"Why setState() act like an async function\"></a>Why setState() act like an async function</h2><p>(This section is a recap on Dan Abramov’s response to the question posed in <a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\">RFClarification: why is setState asynchronous?</a>)</p>\n<p>In daily life, tasks that require immediate attention are important to us, while tasks we procrastinate on are often less critical. Similarly, not every state update triggered by <code>setState()</code> is of the highest priority.</p>\n<p>This is where the first reason of asynchronously <code>setState</code> comes into play: priority scheduling.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>React could assign different priorities to setState() calls depending on where they’re coming from: an event handler, a network response, an animation, etc.</p></blockquote>\n<h3 id=\"Reason-1-ensures-concurrent-features\"><a href=\"#Reason-1-ensures-concurrent-features\" class=\"headerlink\" title=\"Reason 1: ensures concurrent features\"></a>Reason 1: ensures concurrent features</h3><p><strong>Example</strong><br>Imagine you’re editing a post on social media while getting a dozen of new notification messages.<br>If there are 100+ or even 500+ new messages, there may be no response to your keyboard input, as the browser is busy updating new notifications.</p>\n<p><strong>For the above situation, what can you do to ensure smooth text input for users?</strong><br>A good practice is: giving low priority to message updates, as they are less important in this case. And when a message update encounters a high priority event, we will ask the former one to yield the main thread.</p>\n<p><strong>Why asynchronous <code>setState()</code> benefits prioritized rendering (concurrent features) in React?</strong><br>This is because async-like <code>setState()</code> makes concurrent features possible, by delaying execution of low priority task and making room for high priority ones.</p>\n<h3 id=\"Reason-2-avoid-dirty-data\"><a href=\"#Reason-2-avoid-dirty-data\" class=\"headerlink\" title=\"Reason 2: avoid dirty data\"></a>Reason 2: avoid dirty data</h3><p>Besides performance optimization, avoiding dirty data is another reason not to run <code>setState()</code> in a synchronous way. To understand this, we need to talk about the core value of React first.</p>\n<p><strong>React In Theory</strong></p>\n<p>For React, its most fundamental principle evolved from this formula:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>UI &#x3D; f(state)</p></blockquote>\n<p>The concept behind this idea is straightforward: if you have the same input states for your application, it should always produce the same user interface (UI).</p>\n<p>However, running <code>setState()</code> synchronously may violate React’s pure-function-like update processes: <strong>It is hard to ensure consistency on synchronously updated states and their props.</strong>  </p>\n<p>When a sync <code>setState()</code> is fired, its related props have to wait for reconciliation or flushSync to happen for corresponding updates. Such inconsistency can lead to unpredictable state updates in a React App.</p>\n<p>To feel such consistency, you can try this example:</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">function App() &#123;\n  let [count, updateCount] &#x3D; useState(0);\n  console.log(&#39;render cycle&#39;, count);\n\n  const clickMe &#x3D; () &#x3D;&gt; &#123;\n    updateCount(count + 1);\n    console.log(&#39;click me:&#39;, count);\n  &#125;\n\n  const clickFox &#x3D; () &#x3D;&gt; &#123;\n    count +&#x3D; 1;\n    console.log(&#39;click fox:&#39;, count);\n  &#125;\n\n  return (\n  &lt;&gt;\n    &lt;button onClick&#x3D;&#123;clickMe&#125;&gt;click me&lt;&#x2F;button&gt;\n    &lt;button onClick&#x3D;&#123;clickFox&#125;&gt;click fox&lt;&#x2F;button&gt;\n    &lt;Child count&#x3D;&#123;count&#125; updateCount&#x3D;&#123;updateCount&#125;&#x2F;&gt;\n  &lt;&#x2F;&gt;\n  )\n&#125;\n\nfunction Child(&#123; count, updateCount &#125;) &#123;\n  const updateOnChild &#x3D; () &#x3D;&gt; updateCount(count + 1);\n  return (&lt;button onClick&#x3D;&#123;updateOnChild&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;)\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>In the above example, <code>clickMe</code> is a function that calls <code>updateCount</code> asynchronously and will trigger a re-rendering of this App. Such characteristics ensure consistency between the <code>count</code> state, and its corresponding <code>props</code> passed to the Child component.</p>\n<p>If you try <code>clickFox</code>, every time when you click on <code>click fox</code>, a new value of count is immediately logged to the console. However, while “click fox” immediately updates the <code>count</code> state, the prop <code>count</code> still refers to the old value resulted from the last reconciliation.</p>\n<p>Such inconsistency in states and props can cause unpredictable behavior in an App.</p>\n<p>Please note: directly updating a state by <code>&quot;=&quot;</code> will not cause any re-rendering in a React App, unless we update the state with setState or useState hooks.<br>Here we only use the <code>click fox</code> example to mock the situation that a state changes inconsistently with related props, and its potential issues.</p>\n<h2 id=\"What-makes-sync-setState-act-asynchronously\"><a href=\"#What-makes-sync-setState-act-asynchronously\" class=\"headerlink\" title=\"What makes sync setState() act asynchronously\"></a>What makes sync setState() act asynchronously</h2><p>Every time <code>renderRoot</code> or <code>setState</code> is triggered, React doesn’t immediately start rendering in a React App. Instead, React will first schedule the updates, assigning different priority levels to each task and combining multiple tasks into one.</p>\n<p>Because of this, synchronous <code>setState()</code> calls are collected in an <code>updateQueue</code>.<br>The way <code>updateQueue</code> implemented gives <code>setState()</code> asynchronous behaviors: </p>\n<ul>\n<li><code>normal setState()</code> calls will be handled within a micro task queue</li>\n<li><code>concurrent featured setState()</code> calls are handled in a macro task queue</li>\n</ul>\n<p><strong>You might be wondering how to prove that <code>setState()</code> itself is synchronous?</strong><br>A classic example is: Prior to React 18, if you called <code>setState()</code> within <code>setTimeout()</code>, you would notice that it executes immediately, as setState called in setTimeout or native events are not collected in the <code>updateQueue</code> of React. </p>\n<p>(In React 18, this issue has been addressed, and <code>setState()</code> calls made within <code>setTimeout()</code> are now asynchronous as well)</p>\n<h2 id=\"Microtask-or-Macrotask\"><a href=\"#Microtask-or-Macrotask\" class=\"headerlink\" title=\"Microtask or Macrotask\"></a>Microtask or Macrotask</h2><p>When updating, if React encounters a high-priority task, it will not execute the next low-priority task and schedule the highest-priority task to be executed.</p>\n<p><strong>How does React implement this (let high priority tasks cut in line)?</strong><br>When it comes to the JavaScript event loop, a common method of interrupting is to let the newly added microtask interrupt the execution of existing macro tasks.<br>We also know that React update functions (setState) are often processed as microtasks.</p>\n<p><strong>Take the concurrent feature as an example:</strong><br>To interrupt low-priority tasks, we mark the tasks in a concurrent feature API as low-priority and put them in a macro task queue.<br>In this way, when higher-priority microtask updates appear, they can jump ahead of the current low-priority macro tasks and be processed first.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\">RFClarification: why is setState asynchronous?</a></li>\n<li><a href=\"https://github.com/reactwg/react-18/discussions/21\">Automatic batching for fewer renders in React 18</a></li>\n</ol>\n","text":"Whether setState is synchronous or asynchronous has become a cliché these days. However, as React is constantly evolving, a frontend program...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"React","slug":"React","count":5,"path":"api/tags/React.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Ideas-of-this-article\"><span class=\"toc-text\">Ideas of this article</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Why-setState-act-like-an-async-function\"><span class=\"toc-text\">Why setState() act like an async function</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reason-1-ensures-concurrent-features\"><span class=\"toc-text\">Reason 1: ensures concurrent features</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Reason-2-avoid-dirty-data\"><span class=\"toc-text\">Reason 2: avoid dirty data</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#What-makes-sync-setState-act-asynchronously\"><span class=\"toc-text\">What makes sync setState() act asynchronously</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Microtask-or-Macrotask\"><span class=\"toc-text\">Microtask or Macrotask</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Reference\"><span class=\"toc-text\">Reference</span></a></li></ol>","author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Single-threaded JavaScript","uid":"e3fb0e6e7c44f4a9d38a4589b5569d51","slug":"single-threaded-javascript","date":"2023-02-08T19:33:14.000Z","updated":"2023-03-01T17:36:46.956Z","comments":true,"path":"api/articles/single-threaded-javascript.json","keywords":null,"cover":[],"text":"This article will illustrate why we have synchronous and asynchronous tasks. Synchronous and Asynchronous TasksIn JavaScript, we have synchr...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}],"author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Ideas behind concurrent features","uid":"cde1a0943957747e6b9bbb6c795024ad","slug":"simple-ideas-about-React-Concurrent-mode","date":"2023-02-06T17:21:10.000Z","updated":"2023-03-03T18:50:24.285Z","comments":true,"path":"api/articles/simple-ideas-about-React-Concurrent-mode.json","keywords":null,"cover":[],"text":"Do React concurrent features mean multitasking?No. React concurrent features are not about multitasking.This is because the JavaScript engin...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"React","slug":"React","count":5,"path":"api/tags/React.json"}],"author":{"name":"flaming-cl","slug":"flaming-cl","avatar":"https://avatars.githubusercontent.com/u/51183663?s=400&u=7addc16053694c5fa5d328409bb44dc2d4d18e4a&v=4","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}