[{"id":"e3fb0e6e7c44f4a9d38a4589b5569d51","title":"Single-threaded JavaScript","content":"Single-threaded JavaScriptThe JavaScript engine is single threaded.\nThis means it only does one thing at a time in the call stack, like the only phone booth in town that only allows one person to make phone calls.\nAlso, function calls that are waiting to be executed are like people who are waiting outside a booth for phone calls.\n\nSync and Aysnc EventsIn JavaScript, we have sync and async calls.\nWhen it comes to our phone booth story, we also have two kinds of people:\n\nPeople who can start their phone call immediately (sync)\nPeople who just stay in the booth , and wait for others to be ready and start a call (async)\n\nNo one would like to be kept waiting outside of a phone booth, but only to see someone stay in the booth doing nothing.\nAn efficient JavaScript engine also does not allow async functions to occupy the call stack and have sync ones to wait.\nCallback Queue and Call StackSo the JavaScript engine will let the sync calls to stay in the call stack, and puts async calls aside for a while.\nFor those async calls, once they are ready to be executed, they will be pushed into a callback queue, waiting to be back to the call stack.Right, they are not pushed into the call stack immediately. Instead, they will be back until the call stack has finished its existing sync calls.\nI think this makes sense, because we do not want to messed up async calls and sync calls.\nWhen an async callback is ready, it is possible that there are still some sync tasks waiting to be execuated in the call stack. At this moment, if we allow a ready async task to jump the queue, you may get confused why a async call is execuated before your sync calls.\nMicrotask and MacrotaskMicrotask\n","slug":"single-threaded-javascript","date":"2023-02-08T19:33:14.000Z","categories_index":"","tags_index":"JavaScript","author_index":"flaming-cl"},{"id":"d7e769e271f05380381ff271e09b897f","title":"Is setState asynchronous?","content":"Ideas of this articleSetState itself is not an asynchronous function, but for some reasons React makes setState act like an async function.\nThis article will:\n\nsummarize why setState() act like an async function.\ndiscuss what makes synchronous setState() to act asynchronously\nprovide an example to tell why async or sync setState matters\n\nWhy setState() act like an async functionWe expect synchronous calls to be executed immediately, while asynchronous calls to be executed after a while.\nIn daily life, what kind of things you will do immediately, and what you will do later?\nObviously, things that are done immediately usually have higher priority, and things delayed are usually less important. Similarly, what we trigger with setState is not always with top priority.\nHere comes the first reason to make setState act in an asynchronous way: priority scheduling. \n\n\n\n\n\n\n\n\n\nReact could assign different priorities to setState() calls depending on where they‚Äôre coming from: an event handler, a network response, an animation, etc.‚Äì Dan Abramov\nReason 1: ensures concurrent featuresExampleAssume you are receiving a bunch of notification messages, while editing a post on social media.\nWhat happens if the notification updates were immediately executed? \nYou may not be annoyed by this when there are only a few messages. But if there are 100+ or even 1000+ new messages, your keyboard input can be very sluggish, as the browser is busy updating new notifications.\nFor the above situation, what can you do to ensure smooth text input for users?\nA good practice is: giving low priority to message updates which are not important in this case. And when a message update encounters a high priority event, we will ask the former one to yield the main thread.\nWhy asynchronous setState() benefits prioritized rendering (concurrent features) in React?Asynchronous-like setState() makes concurrent features possible. \nThis is because async-like setState() makes it easier to delay execution of low priority task and make room for high priority ones.\nTo further understand concurrent features, you can go to this post\nReason 2: avoid dirty dataBesides performance optimization, avoiding dirty data is another reason for us to avoid running setState() in an synchronous way.\nTo understand this, we need to talk about the core value of React first.\nReact In Theory\nFor React, its most fundamental principle evolved from this formula:\n\n\n\n\n\n\n\n\n\nUI &#x3D; f(state)\nThe idea behind it is simple: same input states result in same UI.\nHowever, based on Dan Abramov‚Äôs explanation, running setState() synchronously may violate React‚Äôs pure-function-like update processes.\nWhy running synchronous setState() may violate the core value of React?\nBecause it is hard to ensure consistency on synchronously updated states and their props.\nStates are often not isolated but come with props. To ensure consistent data flow, once you immediately update a state, you also need to update its related props in time.\n\n\n\n\n\n\n\n\n\nHowever, even though you may immediately update a state, props only update after the reconciliation and flushing.\nFor example, although a parent component updates a state immediately, the state related props received by children have to wait until reconciliation or flushing finished.\nSuch inconsistency can lead to dirty data.\nWhat makes synchronous setState() to act asynchronously","slug":"async-setState","date":"2023-02-07T20:07:27.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"fb9f2e7d2bf6b72bb67731a251124487","title":"Questions About React concurrent features","content":"Do React concurrent features mean multitasking?\nNo. React concurrent features are not about multitasking.\nThis is because the JavaScript engine is single-threaded (can only do one thing at one time).\nSo there is no magic for React to simultaneously handle user events while rendering a large list.\n\nIf so, what does React do to avoid stutters when running CPU heavy tasks?In fact, React tries to avoid CPU bottlenecks by running one task, stopping it, running another, and so forth.Sounds like a micro operating system, right?But concurrent features will not allow tasks to freely compete for sources, instead they will label some tasks with low priority. This means these low priority tasks will yield the main thread to more urgent tasks to ensure performance.\nThis is quite similar to how we answer a second phone call:\n\n\n\n\n\n\n\n\n\nAssume there comes a food delivery call, while we are calling a friend for a casual chat.Since a food delivery call is more urgent than a casual chat, we hold the chat and answer the delivery call.\n\nReact does the same thing. It can pause a less prioritized rendering task and yield to more urgent tasks, such as keyboard events which need immediate responds.\nCan you give some examples about React concurrent features?Concurrent features: startTransition(), useTransition(), useDeferredValue()By using the above APIs, you are telling React to give lower priority to things you put in them. \n1ÔºâuseDeferredValue(value)\n\nexample: input value of a search bar\nresult: updates of the input value will be deferred, just like what ‚Äúdebounce‚Äù does\n\n2ÔºâstartTransition(callback)\n\nexample: a function to update a large list\nresult: When updating the large list, if there comes a keyboard event, React will pause the ongoing update and turn to the user event.\n\nWhat enables React to run the concurrent features?Time slicing.After V16, React started to embrace time slicing to ensure an interruptible render phase.This means React can insert urgent browser tasks among small tasks from the render phase to avoid stutter.\nTo understand more about time slicing, go to this post\nReferences[1] Visualization of async rendering and synchronous rendering in React, Andrew Clark[2] useTransition, React Docs[3] useDeferredValue, React Docs\n","slug":"simple-ideas-about-React-Concurrent-mode","date":"2023-02-06T17:21:10.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"adfd66f4376cbd49d3c1a235fa3bacdf","title":"React little by little 3 - Render Phase","content":"Recap: Time Sliced Work LoopFrom the time slicing post, we have known React implements an interruptible render phase by a conditional while loop: once shouldYield turns True, the current reconciliation job can be paused, leaving the main thread to more prioritized jobs, like a user event.\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\nToday we are going to talk about the render phase of React, which is implemented via performUnitOfWork inside each work loop.\nQuestion: Do you think where we should put our code for the commit phase?\n\nWe should put it outside the breakable while loop.      \nThis is because the commit phase can not be paused: we do not want to see our App rendered with some half updated states.\n\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        performUnitOfWork(\n            workInProgress\n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    commitWork(); // the commit phase\n    requestIdleCallback(workLoop)\n&#125;\n\n\n\n\nThe Render PhasePerformUnitOfWork (the render phase) mainly does two things: beginWork and completeWork. Its code could be written like this:\nlet workInProgress = null;\n\nfunction performUnitOfWork(fiber: FiberNode) &#123;\n    const next = beginWork(fiber);\n    fiber.memorizedProps = fiber.pendingProps;\n\n    if (next === null) &#123;\n        completeUnitOfWork(fiber);\n    &#125; else &#123;\n        workInProgress = next;\n    &#125;\n&#125;\nAn Overview of PerformUnitOfWorkBefore understanding key responsibilities of performUnitOfWork, we first have an overview about how React calls performUnitOfWork to reconcile a Fiber tree.\n\nbeginWorkWhat does beginWork do?Each time, performUnitOfWork calls beginWork with the WIP (work in progress) fiber node to do the reconciliation job and return a reconciled child Fiber node (return null if no child). \nExecution order of beginWork calls  The execution order of beginWork calls is similar to a preorder traversal of a tree, like succession to a monarchy‚Äôs throne:\n\n\n\n\n\n\n\n\n\n1st kid ‚û° 1st grandchildren ‚û° 1st great-grandchildren ‚û° ‚Ä¶ ‚û° the 1st no-kid offspring‚û° second in line sibling ‚û° 1st kid of second in line sibling ‚û° ‚Ä¶\n  True or False: The 1st Fiber node enters completeWork is the deepest node in a Fiber tree. \n          \n          False. The first Fiber node enters completeWork is the left most leaf node in an App.\n          \n     \n\nAfter beginWorkWhen beginWork finishes its work, we update the current props in the Fiber node.The next step depends on whether the current Fiber node has a child node:\n\nchild ‚úÖ, performUnitOfWork will pass the child to the next performUnitOfWork call.\nchild ‚ùå, performUnitOfWork will leave the current node to completeUnitOfWork.\n\ncompleteUnitOfWorkThen, performUnitOfWork calls completeUnitOfWork:\nfunction completeUnitOfWork(fiber: FiberNode) &#123;\n    let node: FiberNode | null = fiber;\n\n    do &#123;\n        completeWork(node); \n        const sibling = node.sibling;\n\n        if (sibling !== null) &#123;\n            workInProgress = sibling;\n            return;\n        &#125;\n\n        node = node.return;\n        workInProgress = node;\n    &#125; while (node !== null);\n&#125;\nInside completeUnitOfWork, we first call completeWork to create a DOM instance for the WIP fiber node and handle its effects&#x2F;flags. After that, the while loop has 3 options:\n\nOption 1, the WIP node has a sibling node ‚úÖ: beginWork(sibling)\nOption 2, sibling node ‚ùå , parent node ‚úÖ : completeWork(parent)\nOption 3, sibling node ‚ùå , parent node ‚ùå : stop the work loop\n\nTest your understandingNow we have had an overview of the reconciliation work loop.To test how you understand what we have learned, give it a whirl on the following question.\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nQuestion: Please list all the beginWork and completeWork calls of this App during a render phase in sequence.\nFor example, 1. beginWork(hostFiberRoot) 2. beginWork(App) 3. beginWork(div)\n\n\n\n\nNote: DIV is a host component. ‚Äúlittle by little‚Äù is a text component.\nInterview TrickYou may wonder why we spend so much time on a general understanding of the render phase. By understanding it, you can solve many interview questions on the rendering path of an APP.\nLet us look at an interview question:\nimport React, &#123; useEffect &#125; from \"react\";\n\nfunction A() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount A\");\n  &#125;, []);\n  console.log(\"A\");\n  return &lt;B />;\n&#125;\n\nfunction B() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount B\");\n  &#125;, []);\n  console.log(\"B\");\n  return &lt;C />;\n&#125;\n\nfunction C() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount C\");\n  &#125;, []);\n  console.log(\"C\");\n  return null;\n&#125;\n\nfunction D() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount D\");\n  &#125;, []);\n  console.log(\"D\");\n  return null;\n&#125;\n\nfunction App() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount App\");\n  &#125;, []);\n  console.log(\"App\");\n  return (\n    &lt;div>\n      &lt;A />\n      &lt;D />\n    &lt;/div>\n  );\n&#125;\n\nexport default App;\nWhat does the above code snippet output by calling console.log?App    \nA    \nB    \nC    \nD     \nMount C    \nMount B     \nMount A    \nMount D   \nMount App  \n\n\nConsole.log(‚ÄúX‚Äù) is called when we enter a component. \n\n\n\n\n\n\n\n\nOrders of entering a component are the same as how we call beginWork (like a preorder traversal).\n\nConsole.log(‚ÄúMount X‚Äù) inside useEffect(() &#x3D;&gt; {}, []) is called after a component is rendered. \n\n\n\n\n\n\n\n\nOrders of rendering a component are the same as how we call completeWork (like a postorder traversal).\n\n\nBut can you tell the reasons for your answer? It is time to take a closer look at beginWork and completeWork.\n","slug":"react-render-phase","date":"2023-01-13T13:41:00.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"6f24cb5d48daf65e1958eb9ee89fd0c6","title":"Trie based router","content":"Why trie based routerIf you do not have performance issues, adopting a trie based router might become a premature optimization. In this case, Regex based routing is fast enough, as Regex are compiled down to native code in modern browsers, like Chrome.\nHowever, if you feel tradition MVC routing results in performance pressure on your web App, you can take a look at trie based router. Here is an example from Ayende Rahien.   \n\n\n\n\n\n\n\n\n\nTraditional MVC routing infrastructure can consume a significant amount of time,leaving little time for handling actual requests.By using a trie based router, it is possible to reduce time spent on routing infrastructure,and increase time spent on actual request handling.\nHow to implement Router trieA route mainly does two things: registering a route with a function; matching a route.Here we use trie to register and match routes.\n1. Register a routeFirst, split the route into an array of routes.e.g. ‚Äú&#x2F;courses&#x2F;:id‚Äù &#x3D;&gt; [‚Äúcourses‚Äù, ‚Äú:id‚Äù]\nconst add = (route) => &#123;\n    if (typeof route !== 'string') &#123;\n        throw TypeError('route should be string');\n    &#125;\n    this.currentRoutes = splitRoute(route);\n    return this.createTrieNode(0, this.trie);\n&#125;\nNext, recursively add each segment of the route array to our trie.\n\n1&#x2F; Handle ‚Äú:‚Äù for dynamic values, ‚Äú*‚Äù for wildcard (any value)\n2&#x2F; If a segment is found in our trie, check the next one\n‚Äúcourses‚Äù is shared in the trie, if we have both courses&#x2F;:id and courses&#x2F;ranking\n\n\n3&#x2F; If not found, create a trie node for this segment const createTrieNode = (index, trie) => &#123;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n        \n    let node = null;\n    if (HAS_SPECIAL_SYMBOL) &#123;\n        handleSpecialSymbol();\n    &#125; else if (trie.nodes.has(thisRoute)) &#123;\n        node = trie.nodes[thisRoute];\n    &#125; else &#123;\n        node = this.createNewNodes();\n        trie.nodes[thisRoute] = node;     \n    &#125;\n\n    return this.createTrieNode(index + 1, node);\n&#125;\n\n2. Match a routeLogics for match() a route is quite similar to add().The main difference is in match() we also handle params for a route (if found).\nconst match = (route) => &#123;\n    this.currentRoutes = splitRoute(route);\n    this.currentParams = &#123;&#125;;\n        \n    const node = search(0, this.trie);\n    if (!node) return undefined;\n        \n    node = new Map(node);\n    node.params = this.currentParams;\n    return node;\n&#125;\nWhat does search() do?If a node is found, search() recursively calls itself, with the next segment and the matching node as arguments.\nconst search = (index, trie) => &#123;\n    if (trie === undefined) return trie;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n\n    if (trie.nodes.has(thisRoute)) &#123;\n        return search(index + 1, trie.nodes[thisRoute]);\n    &#125;\n\n    if (trie.name) &#123;\n        // add params\n    &#125;\n\n    if (trie.wildCard) &#123;\n        // add params\n    &#125;\n\n    return search(index + 1);\n&#125;\nFor full implementation, check here.\nReferences[1] Trie based routing, Ayende Rahien[2] A composable trie based router, Wayfarer[3] Trie based routing instead of Regex based routing, React router\n","slug":"dsa_for_web_trie_router","date":"2022-12-21T18:04:15.000Z","categories_index":"","tags_index":"DSA for web dev","author_index":"flaming-cl"},{"id":"62708f443f37b12bd82e694a7acb90fc","title":"React little by little 2 - Fiber Tree","content":"\n\n\n\n\n\n\n\n\nPlato said life is like being chained up in a cave, forced to watch shadows flitting across a stone wall.\nWe are not talking about philosophy today, but use Allegory of the Cave to describe the relationship between React applications and what is under the hood:\nReact applications we see today are mainly results of the render phase and the commit phase.Just like shadows in the eyes of prisoners are results of sun reflection and real world activities.\n\nWhat is under the hoodBefore we see any changes in an application, React does three things: Scheduling, Rendering and commit. What are these? In plain English, they are just:\n\nScheduling üóìÔ∏è: schedule and manage tasks \nRender üîé üå≤ üèÅ: figure out changes made in React applications\nCommit ‚òëÔ∏è : apply these changes to browser DOM\n\nTo understand React, we will start from the render phase. To understand the render phase, we need to understand the React Fiber data structure.\nIn this post, I will cover 2 topics about React Fiber:\n\nHow does React create the first Fiber node?\nWhat are the main properties of a Fiber node?\n\n\nHow does React build a Fiber Tree from the first Fiber node during mounting?\n\nInside React Reconciliation: Fiber TreesFrequent DOM manipulations are expensive for complicated web applications.In this case, we had better only applies changes to the real DOM during state&#x2F;props updates.But changes might spread all over the whole tree, to locate them, we can compare two versions (previous &amp; current) of a virtual DOM tree. This process is called Reconciliation in React.\nQuestion: What is a virtual DOM tree called in React 18?Fiber tree, a singly linked list tree.To understand Fiber tree, we can start from the most basic unit of it, a Fiber node.\nHow does React generate the first Fiber nodeA Fiber node is just a plain JavaScript object.But it may be the object you have never seen before, since it is not exposed to React users.Let us start from something we are familiar with‚ÄîReact Components.\nReact Components, Elements, Fiber NodeThe process of building a Fiber node is the process of converting React Component JSX &#x3D;&gt; a React Element &#x3D;&gt; a Fiber node. \n JSX \n\n\n\n\n\n\n\n\n\n\n\nA syntax extension to JavaScript that allows writing HTML in React components\n\n\n\n React Element \n\n\n\n\n\n\n\n\n\n\n\nThe smallest building blocks of React apps, describing what to render to a React UI environment\n\n\n\n Fiber node \n\n\n\n\n\n\n\n\n\n\n\nA basic unit of work to locate or commit changes in React applications\n\n\n\nFrom React Component to React ElementWe know that React components return JSX. But what does JSX produces?\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\nJSX produces React elements.For example, App is a React component; &lt;App &#x2F; &gt; is a React element in the form of JSX.If you put &lt;App &#x2F; &gt; into Babel, you will get:\n/*#__PURE__*/React.createElement(App, null);\nIt is just a JavaScript object:\nconsole.log(React.createElement(App, null));\n\n/*\n&#123;\ntype: ∆í App(), // e.g. functional component, or HTML tag type like div, p, h1\nkey: null, // e.g. keys you set up in a React component\nref: null,\nprops: &#123;&#125;, // e.g. React component props\n_store: &#123;&#125;,\n_owner: null,\n&#125;\n*/\nTake a closer look at this React Element object, and answer this question:\nCan a React Element be the unit of work to do the Reconciliation job? \n\n\nNo. For Reconciliation, a React element can be too static and isolated:\n\nData stored in it is comparatively static. It mainly explains what this React element looks like.\n\n\n\n\n\n\n\n\nFor reconciliation, we need more dynamic data about its state&#x2F;effect changes or priority scheduling.\n\nIt does not show connections with its children&#x2F;sibling&#x2F;parent Elements.\n\n\n\n\n\n\n\n\nWhen we have finished processing it, we have no way to find the next unit of work.\n\n\nFor reconciliation, we need an upgraded version of React Element. That is where Fiber node comes in.\n\n\n\nFrom React Element to Fiber nodeWe can create a Fiber root node for the React element &lt;App &#x2F; &gt;, by calling:\nconst rootElement = document.getElementById(\"root\");\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nTo see what is inside a Fiber node (React 18.2.0), you can try this:\nconst reactContainerKey = Object.keys(rootElement)[0]; // __reactContainer$cjvrzgbs4i4 \nconsole.log(rootElement[reactContainerKey]) // Fiber root node\n\nTo make it easier to understand, I break down properties of a Fiber node object into 4 parts:\n\nBasic Fiber node info\nTree pointers\nEffect &amp; reconciliation\nScheduling\n\nHere is a cheatsheet for a React Fiber node:\n\nAt this moment, just take a glimpse at this Fiber node.Knowing it also tells something about Reconciliation, Scheduling and its neighbor nodes is enough at this moment. \nHow does React build a Fiber tree from the Fiber root node?Now we have created a Fiber root node.Before mount (first time rendering), React does three things:\n\nCreate a Fiber root node for the whole App.\nCreate a Host Fiber node for the rootElement DOM element.\nLink the Fiber root node with the host Fiber node, using the ‚Äúcurrent‚Äù pointer.\n\n\nDuring mounting, React will also create an alternative host Fiber node.This is different from our existing one, as its child node is not null but a tree of Fiber nodes, which correspond to each React element listed in the app.\nThe alternative host Fiber node, along with its descendant Fiber nodes, is called the workInProgress (WIP) Fiber tree.\nLook at the above pic, you may wonder: Why two host root nodes? What is double buffering? \n\n\nHere is an illustration from game programming patterns:\n\n\n\n\n\n\n\n\n\nImagine we are watching a play.When scene 1 is finished, we will have a 5-minute scene transition, leaving the audience in dark and silence. This is normal in a real world theatre play.But if we leave game players in a black screen for a few seconds, this may drive people nuts.\nIn both game programming and React, we hope to avoid this blank transition by a technique called Double Buffering.Back to our theatre play example, we avoid the silent transition by running two stages (double buffering): \n\nstage A is on show for the current scene \nstage B is adjusting lights or removing&#x2F;changing play props for the next scene\n\nOnce the current scene is finished on stage A, we immediately light on stage B to go to the next scene seamlessly. Now stage A is in dark preparing the next scene settings. \nSo in React, double buffering means switching between the current fiber tree and a workInProgress fiber tree for seamless transitions between rendering.\n\n\n\n\nWe therefore have finished a simple tour about first time rendering in React.\nReferences[1] Double Buffering[2] Allegory of the Cave\n","slug":"react-fiber-tree","date":"2022-11-23T04:40:35.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"87eff45d285eb86c0eaa49c27b6abfb9","title":"Exploring the Benefits of Locality in Memory","content":"As stated in Computer Systems: A Programmer‚Äôs Perspective:\n\n\n\n\n\n\n\n\n\nWell-written computer programs tend to exhibit good locality\nWhat is localityIf you haven't heard of locality, click here.\n\n \n\n\n\n\n\n\n\n\n\nLocality is often described as temporal locality and spatial locality.\n1. Spatial localityGood practice: reference a memory location and then its neighbors\nPoor spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (j &#x3D; 0; j &lt; N; j++)\n    for (i &#x3D;0: i &lt; M; i++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code jumping through elements of different rows in the matrix.\nAssume you are going to buy groceries and books. With poor spatial locality, you  do this:\n\nbuy tomatoes first, and go to a book store for a Math book.\nback to the grocery store for milk, and go to the book store again for a comic book.\n\nBetter spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (i &#x3D; 0; i &lt; M; i++)\n    for (j &#x3D;0: j &lt; N; j++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code reads all the elements in a row and then the next row.\nBack to our grocery example, this time you buy everything from the grocery store first.Later to buy all the books you need from the book store.\n2. Temporal localityGood practice: reference a memory location multiple times\nGood temporal localityOur code above repeatedly reference the same variables (i, j) and enjoy good temporal locality.\n\n\n\nExample in JavaScriptCan we have good spatial locality if we loop cols before rows like this?\nfunction farAccess(data) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      data[j * ROWS + i].x = 1;\n    &#125;\n  &#125;\n&#125;\nLet‚Äôs look at an example given by Yonatan Kra:\n1&#x2F; Create an array of 1,000,000 instances.\nconst ROWS = 1000, COLS = 1000, REPEATS = 1000;\nconst testArray = new Array(ROWS * COLS).fill(0).map((a, i) => new Boom(i));\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n2:Boom &#123;id: 2, x: 0&#125;\n3:Boom &#123;id: 3, x: 0&#125;\n...\n999999:Boom &#123;id: 999999, x: 0&#125;\n2&#x2F; Create a tricky array.\nconst trickyArray = new Array(ROWS * COLS).fill(0);\nfor (let col = 0; col &lt; COLS; col++) &#123;\n    for (let row = 0; row &lt; ROWS; row++) &#123;\n        trickyArray[row * ROWS + col] = arr[col * COLS + row];\n    &#125;\n&#125;\n3&#x2F; Write two functions with good&#x2F;bad spatial locality. \nfunction runGoodSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; ROWS; i++) &#123;\n    for (let j = 0; j &lt; COLS; j++) &#123;\n      arr[i * ROWS + j].x = 0;\n    &#125;\n  &#125;\n&#125;\n\nfunction runPoorSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      arr[j * ROWS + i].x = 0;\n    &#125;\n  &#125;\n&#125;\n4&#x2F; Test performance\nfunction timeit(cb, type) &#123;\n    console.log(`Started data $&#123;type&#125;`);\n    const start = performance.now();\n    for (let i = 0; i &lt; repeats; i++) &#123;\n        cb();\n    &#125;\n    const end = performance.now();\n    console.log(\n        `Finished data locality test run in $&#123;((end - start) / 1000).toFixed(\n            4\n        )&#125; seconds`\n    );\n    return end - start;\n&#125;\n\ntimeit(() => runGoodSpatialLocality(testArray), \"good\");\nsetTimeout(() => &#123;\n    timeit(() => runPoorSpatialLocality(testArray), \"bad\");\n    setTimeout(() => &#123;\n        timeit(() => runPoorSpatialLocality(trickyArray), \"tricky\");\n    &#125;, 2000);\n&#125;, 2000);\n5&#x2F; ResultsThe second function call with bad locality is more than 2 times slower.This is because it makes the CPU chasing its tail to jump between N (length of a row) stride of memory, during each access.But why the third function call with bad locality and the tricky array is still fast? \nFinished good data locality test in 5.1799 seconds\nFinished bad data locality test in 13.9438 seconds\nFinished tricky data locality test in 5.4242 seconds\nBecause our tricky array still access 1-stride of an array:Although we access the whole array by index 0, 1000, ‚Ä¶our tricky array just put elements with 1-stride of memory on index 0, 1000, 2000, ‚Ä¶ like this:\n// trickArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1000, x: 0&#125;\n1000:Boom &#123;id: 1, x: 0&#125;\n1001:Boom &#123;id: 1001, x: 0&#125;\n2000:Boom &#123;id: 2, x: 0&#125;\n...\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n1000:Boom &#123;id: 1000, x: 0&#125;\n2000:Boom &#123;id: 1000, x: 0&#125;\n...\nNow we get the answer: Yes.Even though we run a COL loop first and a ROW loop later,as we still access a memory location and its neighbors in memory,we can have good spatial locality.\nReferences[1] Computer Systems: A Programmer‚Äôs Perspective[2] Memory in Javascript‚ÄîBeyond Leaks[3] Stride, Caches, CS61C lab12\n","slug":"locality","date":"2022-11-10T18:04:15.000Z","categories_index":"","tags_index":"","author_index":"flaming-cl"},{"id":"99d43e98bfd9f53d563dc10659241159","title":"React little by little 1 -  Time Slicing","content":"You may have heard people saying ‚ÄúReact is fast‚Äù as it uses virtual DOM.But is virtual DOM the only thing you can think of when talking about React performance?In fact React has done many things to handle performance issues.\nToday I will talk about Time Slicing.A technique React uses to solve performance bottleneck.\nEvent Loop and CPU bottlenecksEvent LoopModern browsers run a continuous event loop at a certain frequency - e.g. 60Hz (refresh 60 times a second). For smooth and responsive experience, browsers try to complete tasks within each event loop execution, aka a frame.\n\nFor 60Hz refresh rate devices, each execution frame has a budget of 16.66ms (1 second &#x2F; 60).\nCPU bottlenecksWithin such a shoestring budget, browsers have to handle a pipeline of work like this:\n\nIf any step in this pipeline needs more than 16.66ms, no time will be left for the upcoming work in this frame.This means we will not have time for style calculations, layout, paint and compositing, when we spend too much time on JavaScript jobs.When this lasts for 2 or 3 seconds, users will feel your website is slow.\nHow does React avoid this scenario?React sets up an interval for running JavaScript tasks in each frame.When running out of this interval, React will pause its current tasks and give back control to the main thread, letting it perform high priority tasks (painting or user events).After the main thread has finished prioritized jobs, React goes back to where it stopped and continues working.\nAs you may have noticed, the key here is to make React interruptible.\nTime Slicing and Interruptible ReactAssume we have a large application with 500+ components to render.\nWhile rendering these components, how does React ensure responsiveness for keyboard or mouse events?Before React 16, the render phase was synchronize and uninterruptible.The browser therefore would be easily occupied by CPU-hungry tasks,and unable to give prompt responses to user events.Take a look at this video to see what CPU-heavy tasks could be like.\nSo, how did React overcome this?Answer: Time Slicing.\nHere is a picture of time slicing in React (idea of Andrew Clark from the React core team).\n\nInterruptible render phaseAfter version 16, React started using Fiber reconciler to ensure the render phase is interruptible. It breaks down the render phase into time slices so that it can pause current work to run more urgent tasks, like user inputs.As shown in the above picture, time slicing enables browser events to cut in line during the render phase. This helps React to avoid ‚Äúhiccup‚Äù moments.\nUninterruptible commit phaseUnlike the render phase, the commit phase can not be interrupted.You can think of these two like a movie screenplay and a movie on show.When a movie is on (the commit phase), theatres will not suddenly stop playing or change its order of scenes. Just like React will not draw some semi-calculated UI or suddenly stop the commit phase.\nInterruptible Work LoopBefore version 16, React reconciler is implemented by call stack recursion. However, stack Reconciliation will not allow pauses on a running task during the render phase.As mentioned earlier, a high performance render phase is time sliced and interruptible. To implement this, we can change the call stack recursion to conditional while loop recursion:\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\n\nwhile (workInProgress !&#x3D;&#x3D; null &amp;&amp; !shouldYield)\n\n\n\n\n\n\n\n\nThis enables us to stop the workLoop, especially when there is no time left in each frame (shouldYield).  \n\nrequestIdleCallback\n\n\n\n\n\n\n\n\nCheck whether the main thread is idle for running sliced tasks.\n\n\nFiber ReconcilerThis interruptable reconciler is called Fiber reconciler in React.To know more about React Fiber, take a look at this post first: React Fiber Tree.\nReferences[1] Sneak Peek: Beyond React 16, Dan Abramov[1] Build your own React, Rodrigo Pombo[2] Event loop: microtasks and macrotasks, javascript.info[3] Visualization of async rendering and synchronous rendering in React, Andrew Clark[4] Reconciliation, React official documents[5] Rendering Performance, Paul Lewis[6] Frame timing, W3C\n","slug":"time-slicing-react","date":"2022-09-28T22:49:47.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"}]