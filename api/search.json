[{"id":"209a99b3228c3d6a24c530e39b14fe15","title":"CS143 Compiler - Basic concepts","content":"1. Lexical Analysis\n\n\n\n\n\n\n\n\nThis term comes from â€œlexiconâ€. In linguistics, a lexicon refers to the vocabulary of a language, including words and phrases. \nIn a compiler, the task of lexical analysis is to break down the source code into a series of â€œtokensâ€, which can be considered the vocabulary of the programming language. \nWhy we donâ€™t call this phase cutting or chopping?This process is not simply â€œcuttingâ€, as it involves identifying and classifying various elements in the source code, such as keywords, identifiers, operators, etc.\n2. Parsing\n\n\n\n\n\n\n\n\nThis term comes from the linguistic term â€œparseâ€, which means to analyze the grammatical structure of a sentence. \nIn a compiler, the task of parsing is to construct the grammatical structure of the source code based on a series of tokens, usually represented as a parse tree or abstract syntax tree. \nWhy we donâ€™t call it assembling?This process is not simply â€œassemblingâ€, as it involves determining the relationships between tokens based on the grammatical rules of the programming language.\n3. Semantic AnalysisAfter understanding the sentence structure, the next step is to try to understand the meaning of what has been written.This is hard and compilers can only do very limited kinds of semantic analysis. They generally try to catch inconsistencies in the program.\n\n\n\n\n\n\n\n\n\nJack said Jerry left his assignment at home\nDo you know whose assignment Jack was talking about?Yes, in English or any other language, we experience ambiguity. But programming languages do not have that much tolerance for ambiguity. So we need to do semantic analysis to ensure that the meaning of each statement in the program is clear and unambiguous. \nExample: Type checkThis involves checking for type mismatches, ensuring that variables are declared before they are used, checking that functions are called with the correct number of arguments, and so on.\n\n\n\n\n\n\n\n\n\nint x &#x3D; â€œhelloâ€;\nThis is a type mismatch and the compiler will throw an error. The compiler, during semantic analysis, will catch this inconsistency, because an integer variable cannot be assigned a string value.\n4. OptimizationThe fourth compiler phase, optimization, is a bit like editing. The goal is to modify the program so that it uses less of some resource, such as time, space, power, etc.\nFor example, the text uses the phrase â€œbut a little bit like endingâ€ and its shorter version â€œbut akin to editingâ€ as an example of optimization in English. \nIn the context of a compiler, an example rule that says X = Y * 0, is the same as X = 0 is used to illustrate the kind of optimizations a compiler might do.\n5. Code GenerationThe last compiler phase is code generation, often referred to as Code Gen. It involves translating the high-level program into some other language, such as assembly code.\nUsing human languages as an analogy, a human translator might translate English into French, a compiler will translate a high-level program into assembly code.\n","slug":"compiler","date":"2023-05-27T20:12:38.000Z","categories_index":"","tags_index":"compiler","author_index":"flaming-cl"},{"id":"663764549142bb4876ce625b417bf9d8","title":"Data Abstraction from SICP","content":"Data AbstractionIn functional programming, data abstraction is a technique that uses functions to hide the details of data structures, and provides a well-defined interface for accessing the data. In this way, the rest of the program does not have to deal with the details of the data structure, but only with the abstraction layer provided by the functions.\nBy encapsulating the data structure, it also becomes easier to modify it in the future. Changes to the data structure can be made by adjusting the implementation of the functions that encapsulate it, without affecting the rest of the program.\nThis article will show you how to use data abstraction to minimize the impact of unpredictable data changes to your program.\nExample: Data abstraction V.S. a plain data handling method\n\n\n\n\n\n\n\n\nWrite a function midpoint_segment to find out the middle point of a certain segment.\nFirst, letâ€™s take a look at how to implement midpoint_segment with data abstraction.\nfunction make_point(x, y) &#123;\n  return &#123;\n    x: x,\n    y: y\n  &#125;;\n&#125;\n\nfunction x_point(point) &#123;\n  return point.x;\n&#125;\n\nfunction y_point(point) &#123;\n  return point.y;\n&#125;\n\nfunction make_segment(start, end) &#123;\n  return &#123;\n    start: start,\n    end: end\n  &#125;;\n&#125;\n\nfunction start_segment(segment) &#123;\n  return segment.start;\n&#125;\n\nfunction end_segment(segment) &#123;\n  return segment.end;\n&#125;\n\nfunction midpoint_segment(segment) &#123;\n  const start = start_segment(segment);\n  const end = end_segment(segment);\n  const mid_x = (x_point(start) + x_point(end)) / 2;\n  const mid_y = (y_point(start) + y_point(end)) / 2;\n  return make_point(mid_x, mid_y);\n&#125;\n\nfunction print_point(point) &#123;\n  console.log(`($&#123;x_point(point)&#125;, $&#123;y_point(point)&#125;)`);\n&#125;\n\nconst segment = make_segment(make_point(1, 2), make_point(5, 6));\nconst midpoint = midpoint_segment(segment);\nprint_point(midpoint);\nIn this case, we simply wrap the data definitions and retrieval operations with functions. By doing so, we avoid exposing the point data to the implementation logic of midpoint_segment. You may think this is redundant and cumbersome, but letâ€™s not jump to conclusions yet and keep reading.\nNow we use a plain method to implement midpoint_segment.\nfunction Point(x, y) &#123;\n  this.x = x;\n  this.y = y;\n&#125;\n\nfunction Segment(start, end) &#123;\n  this.start = start;\n  this.end = end;\n&#125;\n\nfunction midpoint(segment) &#123;\n  const start = segment.start;\n  const end = segment.end;\n  const mid_x = (start.x + end.x) / 2;\n  const mid_y = (start.y + end.y) / 2;\n  return new Point(mid_x, mid_y);\n&#125;\n\nfunction print_point(point) &#123;\n  console.log(`($&#123;point.x&#125;, $&#123;point.y&#125;)`);\n&#125;\n\nconst start = new Point(1, 2);\nconst end = new Point(5, 6);\nconst segment = new Segment(start, end);\nconst mid = midpoint(segment);\nprint_point(mid);\n\nIt looks like our plain method code is concise and readable.\nHowever, is the plain method easier to maintain than data abstraction method?\nPotential problems with plain implementationSuppose in the future, the data structure of a point becomes an array [2, 4]. \nNow, we need to make changes to the implementation of the plain method in all the code that uses point.x and point.y.\nHowever, experienced programmers know that modifying code in multiple places in a complex project is a dangerous signal. No one knows what unknown effects will happen when we let the butterfly flap its wings in a certain piece of code.\nA better way is to try our best to avoid make many changes to our existing code. \nWhy data abstraction helps you to build robust programsNow, we look at our code implemented with data abstraction.\nYou will find you donâ€™t have to search through the whole project to find out how many times you used point.x or point.y.Although you still make a small number of changes, you at least have an overall understanding of its impact to the whole project, reducing the possibility of unknown bugs caused by code modifications.\nfunction make_point(x, y) &#123;\n  return [x, y];\n&#125;\n\nfunction x_point(point) &#123;\n  return point[0];\n&#125;\n\nfunction y_point(point) &#123;\n  return point[1];\n&#125;\n\n// no changes to the rest of the code\nNow, do you prefer to individually wrap your data or leave them scattered?\n)\nData abstraction V.S. Adaptor patternMy Tip: I still donâ€™t think one should stubbornly adhere to a certain method.\nWhen we find certain data is used scatteredly in a project, especially the project may develop into a large-scale project, we can consider using data abstraction.\nIn addition, when facing data changes, another approach is to use the adaptor pattern. Below is a simple comparison between the adaptor pattern and data abstraction:\nAdaptorsPros\n\nAllows easier integration of existing code with new interfaces or data structures.\nEnables reuse of existing code with minimal modifications.\nCan provide a temporary solution for integrating incompatible systems while working on a more permanent solution.\n\nCons\n\nAdds an extra layer of complexity, making code harder to understand and maintain.\nMay not provide a long-term solution, requiring more refactoring in the future.\nPotentially loses some benefits of data abstraction by not fully encapsulating the implementation details.\n\nData AbstractionPros\n\nEncapsulates implementation details, allowing for cleaner and more maintainable code.\nSimplifies code changes by limiting the impact of modifications to the constructor and selector functions.\nPromotes better separation of concerns and modularity in the application.\n\nCons\n\nRequires initial investment in creating constructors and selectors.\n\n","slug":"SICP-2-data-abstraction","date":"2023-03-28T00:14:53.000Z","categories_index":"","tags_index":"Functional-Programming","author_index":"flaming-cl"},{"id":"db38fc973daee4dda97824ebfb5c0041","title":"Recursion, Iteration and Abstraction from SICP","content":"Iâ€™ve recently been reading SICP, a book about programming philosophy. I just finished the 1st chapter yesterday and wanted to share some of my thoughts and insights.\nThe main points in the 1st chapter that got me thinking were:\n\nDifference between Recursion and iteration\nHow to abstract a function to make it more extensible and reusable\n\nRecursive or Iterative ProcessesTo make it easier to understand, Iâ€™ll start by discussing a topic that many frontend developers are familiar with â€“ React.\nRecursive ProcessThe diff algorithm in React prior to version 16 is a prime example of a recursive process.\nDiff Algorithm: To identify the changes in the Virtual DOM, React starts at the root node and recursively traverses the tree. This process consists of expansion and contraction phases.\nExpansion (beginWork)In the expansion phase, we traverse the virtual DOM tree from the root node, exploring child nodes step by step.\nContraction (completeWork)During contraction, we return to the parent node after traversing all child nodes, then proceed to a sibling or parentâ€™s parent.\nA Story to Help You Visualize the ProcessIf the above explanation is still a bit unfamiliar to you, let me tell a story to help you visualize the process:\n\n\nYouâ€™re playing a game where an unknown number of treasures are hidden within an underground mazeâ€™s various rooms. \nWithout a map, you venture deeper into each room to explore. \nAt dead-ends, you backtrack to the nearest fork until you eventually return to the mazeâ€™s entrance to end the game.\n\n\nIn this context, delving into deeper rooms symbolizes an expanding process, akin to exploring new territories. Conversely, backtracking from dead-ends represents a contracting process.\nUnaware of Overall GainNow let us discuss another feature of recursion: before completing the entire recursive process, we are unaware of the overall results, as we only focus on local problems. \nGoing back to the treasure hunting story.While exploring the maze, you are given a magical pocket to conceal all the treasures collected. Only upon completing the adventure, the pocket reveals your accumulated riches. \nIn this case, the uncertainty of your treasure hunting gains mirrors the ambiguity of progress in recursion, where a clear result emerges only upon task completion.\nUninterruptibleAnother problem with recursion is that it is hard to be interrupted and resumed.\nRecursion can be difficult to interrupt and resume, making it hard to pause a task or prioritize more urgent tasks. To make an expandable and contractible process interruptible, we need to combine recursive and iterative processes.\nIterative ProcessIterative processes are repeatable and build upon previous results, allowing for interruptions, resumptions, and data recording for continuity.\nSince React version 16, iteration has been using to traverse the DOM tree through a conditional loop. This enables prioritized tasks to interrupt and later resume the diff process using stored data. Also, it maintains expandable and contractible approaches to traverse a Fiber tree for detecting changes.\nFunction AbstractionI think the most interesting part of this chapter is function abstraction.\nTo explore the beauty of it, letâ€™s start with a simple example, and gradually improve it upon small initiatives. \n\n\n\n\n\n\n\n\n\nCreate a composite function that takes a number as input, and returns the cube of the number after adding 1.\nconst incAndCube = (x) => (x + 1) * (x + 1) * (x + 1);\nHere, repeatedly having x + 1 does not sound good. So letâ€™s abstract it into a function. \nconst inc = (x) => x + 1;\n\nconst incAndCube = (x) => inc(x) * inc(x) * inc(x);\nHigher-order FunctionRight now, though our code looks a bit better, we are still repeating inc 3 times. To improve this, letâ€™s pass inc as a parameter of cube, to make cube a higher-order function and avoid repetitiveness. By using a higher-order function in this case, we can create a more flexible and maintainable solution.\nconst inc = (x) => x + 1;\n\nconst cube = (x) => x * x * x;\n\nconst incAndCube = (x) => cube(inc(x));\n\nYou might feel like it doesnâ€™t make any difference. But donâ€™t worry, the process of iterative improvement often starts with small steps that may seem trivial. By continuously refining our code, we can achieve more extensible and reusable solutions.\nRecursionYou might feel that the cube function does not appear very extensible: what if the requirement changes to multiplying a number by itself 999 times?\nTo make the cube function more extensible, we can create a recursive repeat function which accepts a parameter representing the number of repetitions.\nExpansionLetâ€™s think about this question: what will happen if we use repeat to multiply a number by itself 999 times?We will first come to the expansion phase, as it will generate a massive expression involving 999 multiplication operations gradually. For example, x * x for once, (x * x) * x for twice.\nContractionAfter finished the expansion phase, we start to shrink the large expression to a single number. We can do this by having (result of each multiplication) * (next number).\nWith a clear understanding of expansion and contraction phases, now we can write a recursive repeat function to achieve greater flexibility and extensibility.\nconst inc = (x) => x + 1;\n\nconst repeat = (x, n)  => &#123;\n  if (n === 0) &#123;\n    return 1;\n  &#125;\n  return x * repeat(x, n - 1);\n&#125;\n\nconst cube = (x) => repeat(x, 3);\n\nconst incAndCube = (x) => cube(inc(x));\nExplanation with Code\nExpansion phase: The repeat function, when called with x and n, will recursively call itself until n is reduced to 0. During this process, it creates an expression that multiplies x by itself n times, e.g., x * x for once, (x * x) * x for twice, and so on.\nContraction phase: When n reaches 0, the base case is met, and the recursion starts unwinding. As it returns from each recursive call, it contracts the expression by successively multiplying the result of each multiplication by the next number. Eventually, it arrives at the final result, which is x multiplied by itself n times.\n\nExplanation with InceptionIf you want a more intuitive understanding of this process, think of the movie Inception.\n\nExpansion: main characters delves deeper into dreams, layer by layer.\nBase case met: at the moment the mission is completed, the base case is reached.\nContraction: everyone employs a â€˜kickâ€™ to sequentially fall through dream layers, ultimately returning to reality (layer 0).\n\nNow we have successfully abstracted the cube function and made it more extensible. ðŸŽ‰ðŸŽ‰\nCurryingWait, are we finished? It seems like we havenâ€™t seen any cool techniques yet. For example, where is currying?\nWe definitely can incorporate currying to our existing code. First, letâ€™s try a simple currying by making incAndCube returns a function.\nconst incAndCube = () => x => cube(inc(x));\n\nNow, we incorporated currying in incAndCube. But sorry that this currying doesnâ€™t do anything practical in the first step, nor does it store any temporary variables. It is just for the sake of experiencing the cool currying technique.\nðŸ¤” How about we try to split incAndCube into 2 steps? \n\nThe 1st step is to obtain the function expression for the entire calculation of x.\nThe 2nd step is to substitute x with a value.\n\nFunction CompositionFor the 1st step, we need to write a function to compose the inc and cube functions.Its input is two functions, and its output is the combination of these two functions.\nconst compose = (g, h) => x => g(h(x));\n\nThe above code means that we first calculate h, then calculate g.So we can write the incAndCube function like below, as we need to first calculate inc and then calculate cube.\nconst incAndCube = ()  => &#123;\n  const composedFunc = compose(cube, inc);\n  return x => composedFunc(x);\n&#125;\n\nðŸŒ‡ Now, we finished it! Here is the complete code:\nconst inc = (x) => x + 1;\n\nconst repeat = (x, n)  => &#123;\n  if (n === 0) &#123;\n    return 1;\n  &#125;\n  return x * repeat(x, n - 1);\n&#125;\n\nconst cube = (x) => repeat(x, 3);\n\nconst compose = (g, h) => x => g(h(x));\n\nconst incAndCube = ()  => &#123;\n  const composedFunc = compose(cube, inc);\n  return x => composedFunc(x);\n&#125;\n\nconsole.log(incAndCube()(2));\n\nSing a Different TuneFunctional programming offers advantages in some cases, but itâ€™s not always the best solution for every situation.\nThe original, straightforward definition of incAndCube with three x + 1 multiplications is already simple and easy to understand. In cases where reusability and extensibility arenâ€™t required, this approach saves programming time and remains clear to other developers.\nHowever, in large-scale projects with possible shifting requirements, single-purpose and straightforward functions prove more robust. Consider our basic inc function: if its logic changed from x + 1 to x + 2, weâ€™d have to modify the original code in three places. If the function were more much complex than inc, multiple updates may introduce unforeseen problems.\nIn conclusion, each programming method has its strengths. While functional programming might seem more advanced, itâ€™s not a one-size-fits-all solution. Itâ€™s essential to choose the appropriate approach based on the specific situation and project requirements.\n","slug":"recursion-iteration-and-function-abstraction-md","date":"2023-03-26T23:45:35.000Z","categories_index":"","tags_index":"Functional-Programming","author_index":"flaming-cl"},{"id":"a761733a063b8acf880e89f595a40e38","title":"Demystifying Closures through Narratives","content":"Before I explain the concept of closure, let me share a story with you.\nThe word â€œclosureâ€ evokes a tender memory of my visit to Manchester in 2016.\nDuring my stay, I had the pleasure of living in an Airbnb home of an 80-year-old lady. The old lady was living alone, and her best friend was a cat named Mavis. In 2016, she did not have a smartphone, and her favorite form of entertainment was listening to the radio.\n\nToday, I can still envision her silhouette moving gracefully through the kitchen, preparing breakfast while enjoying her favorite radio program.\nTimes have certainly changed, yet this elderly lady held onto habits from decades ago until today. \nNow, you may wonder, what does this have to do with closure?Well, letâ€™s take a look at the concept of closure:\n\n\n\n\n\n\n\n\n\nClosure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.â€“ You Donâ€™t Know JS (1st edition)\nHave you noticed the similarity between an elderly lady who loves listening to the radio and a closure function remembering its original lexical scope?\nIn the story I shared earlier, the elderly lady (a closure function)  was born in the 1930s (its lexical scope) and developed the habit of getting news from the radio during the time she was born.\nLater, when she entered the 2010s (another lexical scope), smartphones had already invaded the lives of almost everybody, but she still retained the habit that she developed in the 1930sâ€”â€”listening to the radio (access its lexical scope even when that function is executing outside its lexical scope).\nNow, letâ€™s go back to the concept of closure in JavaScript. A closure often has the following characteristics:\n\nA function was born in a lexical scope (i.e., the lexical scope where the function was defined).\nThis function remembers and references variables from the birth scope.\nWhen this function runs in other scopes, it still uses certain variables from the birth scope.\n\nTo illustrate this with code, it would look like this:\nfunction year1930s() &#123;\n  const popularMedia = 'Radio';\n  return function ladyS() &#123;\n    console.log(`$&#123;popularMedia&#125; is my favorite way to get news.`);\n  &#125;\n&#125;\n\nconst ladyS = year1930s();\n\nfunction year2010s() &#123;\n  const popularMedia = 'Smart phone';\n  ladyS(); \n&#125;\n\nyear2010s(); // \"Radio is my favorite way to get news.\"\n\nTo delve a bit deeper, as the closure function is still using variables from the birth scope, these variables cannot be destroyed and still occupy memory (like after the function year1930s is called, the variable popularMedia is still there).\nYeah, in real life, though itâ€™s already the 2020s, home radios havenâ€™t completely disappeared from this world, due to some peopleâ€™s love for nostalgia.\nOf course, there are many other examples that can illustrate how closure works. For instance, many immigrants still have a strong affinity for their hometown food, no matter how long they have lived abroad.\nTo describe this with code, it could look like this:\nfunction lifeInHometown() &#123;\n  const popularFood = 'ðŸŒ¶ï¸ beef noodles';\n  return function kidQ() &#123;\n    console.log(`$&#123;popularFood&#125; is my favorite food.`);\n  &#125;\n&#125;\n\nconst kidQ = lifeInHometown();\n\nfunction lifeInUK() &#123;\n  const popularFood = 'Fish and chips';\n  kidQ();\n&#125;\n\nlifeInUK(); // \"ðŸŒ¶ï¸ beef noodles is my favorite food.\"\n\nLetâ€™s recap the concept of closure:\n\nWhen there is a closure, it must involve two different lexical scopes:\none is the birth lexical scope A, where the function was defined.\nthe other is the lexical scope B, where the function is called later.\n\n\nEven if the function leaves its birthplace closure A and runs in another lexical scope, it still remembers some variables defined in A.\n\nBy now, you should have a grasp of what closure is.\nA troublesome example of closure in React is Stale Closure, which often appears in React hooks and is a pain for many beginners. In the future blog post, I will discuss the Stale Closure issue in React hooks in more detail.\n","slug":"closure_stories","date":"2023-03-03T01:30:37.000Z","categories_index":"","tags_index":"JavaScript","author_index":"flaming-cl"},{"id":"d023e6e193058604027b9567a78aede0","title":"Best Practice of using ref in React hooks","content":"In this article, weâ€™ll be discussing a best practice for using useRef in React, as well as delving into the reasons behind it.\nLetâ€™s first look at a piece of code. What will be logged by this code in the end?\nimport React, &#123; useState, useRef, useEffect &#125; from 'react';\nimport ReactDOM from 'react-dom'\n\nfunction App() &#123;\n  const [show, setShow] = useState(true)\n  return &lt;div>\n    &#123;show &amp;&amp; &lt;Child unmount=&#123;() => setShow(false)&#125; />&#125;\n  &lt;/div>;\n&#125;\n\nfunction Child(&#123; unmount &#125;) &#123;\n  const isMounted = useIsMounted()\n  useEffect(() => &#123;\n    console.log(isMounted)\n    Promise.resolve(true).then(() => &#123;\n      console.log(isMounted)\n    &#125;);\n    unmount(); \n  &#125;, []);\n\n  return null;\n&#125;;\n\nfunction useIsMounted() &#123;\n  const isMounted = useRef(false);\n\n  useEffect(() => &#123;\n    isMounted.current = true;\n    return () => isMounted.current = false;\n  &#125;, []);\n\n  return isMounted.current;\n&#125;\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(&lt;App/>)\nAnswer (click me)\n\n\n// mount \nfalse\n// update\nfalse\n\nfunction Child(&#123; unmount &#125;) &#123;\n  const isMounted &#x3D; useIsMounted() &#x2F;&#x2F; mounting\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(isMounted) &#x2F;&#x2F; mounted\n    Promise.resolve(true).then(() &#x3D;&gt; &#123;\n      console.log(isMounted) &#x2F;&#x2F; update\n    &#125;);\n    unmount(); &#x2F;&#x2F; called when mounted, cause an update\n  &#125;, []);\n\n  return null;\n&#125;;\n\nfunction useIsMounted() &#123;\n  const isMounted &#x3D; useRef(false); &#x2F;&#x2F; mounting\n\n  useEffect(() &#x3D;&gt; &#123;\n    isMounted.current &#x3D; true; &#x2F;&#x2F; mounted\n    return () &#x3D;&gt; isMounted.current &#x3D; false; &#x2F;&#x2F; cleanup function called during next update\n  &#125;, []);\n\n  return isMounted.current; &#x2F;&#x2F; mounting\n&#125;\n\n\n\n\nWhy the above code does not work as expected?Primitive V.S. Reference Data type in JavaScriptWhen you create a copy of a primitive value, such as a string or a number, it is completely independent of the original value. In other words, changing the copy will not affect the original value in any way.\nHowever, when you make a copy of reference data, such as an object or an array, itâ€™s like duplicating a key to a house. If you use this copied key to enter the house and make any changes to the interior, these modifications will be reflected for anyone else who also has access to this house.\nHow primitive data affected the useIsMounted hook?The value returned by useIsMounted is a snapshot of a primitive value during mounting, and any changes made to the ref after that moment will not affect this initially returned value.\nItâ€™s worth noting that refs does not automatically trigger a re-rendering. As a result, the initial value of isMountedfalse is called twice.\nClosure in hooksYou may also be curious about why console.log(isMounted) called with Promise is still false. To understand this, you need a little background knowledge about the execution context of each effect in React.\nYou can think of each render in React as a layer of dreams in the movie â€œInceptionâ€:Data that useEffect can directly access is not infinite in time and space.It can only read the execution context that was created, when the useEffect was called.\nSo, although each update cycle in React will create a new execution context, some hooks might still refer to its old context.\nThis is why the Promise console.log(isMounted) still showed the initial isMounted value, even after unmount() triggered a new update cycle.\nHow should we modify the above code to make it work as expected?Before answering this question, letâ€™s do another quiz:What will be printed after runing the below code?\nimport React, &#123; useState, useRef, useEffect &#125; from \"react\";\nimport ReactDOM from 'react-dom/client';\n\nfunction App() &#123;\n  const [show, setShow] = useState(true);\n  return &lt;div>&#123;show &amp;&amp; &lt;Child setShow=&#123;setShow&#125; />&#125;&lt;/div>;\n&#125;\n\nfunction Child(&#123; setShow &#125;) &#123;\n  const isMounted = useIsMounted();\n\n  useEffect(() => &#123;\n    console.log(isMounted.current);\n    setShow(() => &#123;\n      console.log('update state');\n      return false;\n    &#125;);\n  &#125;, []);\n\n  return null;\n&#125;\n\nfunction useIsMounted() &#123;\n  const isMounted = useRef(2);\n\n  useEffect(() => &#123;\n    isMounted.current += 3;\n    return () => &#123;\n      isMounted.current *= 2\n      console.log(isMounted.current);\n    &#125;;\n  &#125;, []);\n\n  return isMounted;\n&#125;\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root')\n);\nroot.render(&lt; App />)\nAnswer (click me)\n\n\n// mounted\n5\n\"update state\"\n// after state updated\n10\n\n\n\n\nExplanationInstead of returning the isMounted.current value, we are now returning the entire isMounted object. This means, although our reference key (the ref object) was created during mounting, we still can refer to an updated version of the isMounted ref in the componentDidMount lifecycle.\nIn this case, the logged isMounted.current values are as expected:\n\n5: After mounting, the isMounted.current value is 5, which is updated by the useEffect function in the custom hook.\n10: When setShow is triggered, it triggers a re-render of the App component, which causes the Child component to be unmounted and the cleanup function of useIsMounted to be called.\n\n(A tip on useEffect cleanup: React will call your cleanup function each time before the Effect runs again, before the related component unmount)\nAs a result, isMounted.current &#x3D; 10    \nA secret behind useRefThe ref returned by useIsMounted references the same ref object during each rendering (to understand it, try to log isMounted in the above code).\njsximport React, &#123; useState, useRef, useEffect &#125; from &quot;react&quot;;\nimport ReactDOM from &#39;react-dom&#x2F;client&#39;;\n\nfunction App() &#123;\n  const [show, setShow] &#x3D; useState(true);\n  return &lt;div&gt;&#123;show &amp;&amp; &lt;Child setShow&#x3D;&#123;setShow&#125; &#x2F;&gt;&#125;&lt;&#x2F;div&gt;;\n&#125;\n\nfunction Child(&#123; setShow &#125;) &#123;\n  const isMounted &#x3D; useIsMounted();\n\n  useEffect(() &#x3D;&gt; &#123;\n    console.log(isMounted);\n    setShow(() &#x3D;&gt; &#123;\n      console.log(&#39;update state&#39;);\n      return false;\n    &#125;);\n  &#125;, []);\n\n  return null;\n&#125;\n\nfunction useIsMounted() &#123;\n  const isMounted &#x3D; useRef(2);\n\n  useEffect(() &#x3D;&gt; &#123;\n    isMounted.current +&#x3D; 3;\n    return () &#x3D;&gt; &#123;\n      isMounted.current *&#x3D; 2\n      console.log(isMounted);\n    &#125;;\n  &#125;, []);\n\n  return isMounted;\n&#125;\n\nconst root &#x3D; ReactDOM.createRoot(\n  document.getElementById(&#39;root&#39;)\n);\nroot.render(&lt; App &#x2F;&gt;)\n\nCan you take a guess on what will be logged by this code?\nAnswer (click me)\n\n\n&#123;current: 10&#125;\n'update state' \n&#123;current: 10&#125;\n\n\n\n\nExplanationTo understand this, letâ€™s look at the source code of updating refs in React:\nfunction updateRef&lt;T&gt;(initialValue: T): &#123;current: T&#125; &#123;\n  const hook &#x3D; updateWorkInProgressHook();\n  return hook.memoizedState;\n&#125;\nAs you can see, the updated ref object always refers to the initial one.This explains why you see &#123;current: 10&#125; before â€˜update stateâ€™:The ref always points to the same object, and &#123;content:10&#125; is showing its most recent value.If you want a ref to reflect data changes more accurately, you can convert the ref object to a string or call ref.current.\nRecap: best practice of returning a ref in custom hooks\nreturn the ref object itself\ncall ref.current to access the latest value\n\n","slug":"best-practice-of-useRef-and-why","date":"2023-02-28T20:54:29.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"e3fb0e6e7c44f4a9d38a4589b5569d51","title":"Single-threaded JavaScript","content":"This article will illustrate why we have synchronous and asynchronous tasks.\nSynchronous and Asynchronous TasksIn JavaScript, we have synchronous and asynchronous tasks.\nSynchronous TasksSynchronous tasks are processed immediately, and they can block JavaScript execution until the running task is completed.\nAsynchronous TasksAsynchronous tasks, such as I&#x2F;O or network requests, often require interaction with threads other than the JS engine main thread to obtain data for incoming execution.\nAs the main thread is not responsible for I&#x2F;O or network jobs, it really doesnâ€™t need to wait for completion of long-running asynchronous tasks. To improve efficiency, JavaScript asks asynchronous tasks to yield the main thread for the next task, and will execute on ready asynchronous callbacks later.\n\nIllustration for Asynchronous TasksTo better understand asynchronous tasks, letâ€™s look at an example of working as a counter staff at McDonaldâ€™s. Here is a typical scenario of a counter staffâ€™s job:\n\nhave customers waiting in line before serving them\nserve customer A to order food at the counter\ntell customer A to wait for food to be cooked, and start serving customer B\nwhen customer Aâ€™s meal is ready, notify A to be back, pass meals to A and complete service\n\nLetâ€™s take a look at how working as a counter staff at McDonaldâ€™s is similar to task processing in JavaScript:\n\nJavaScript is single-threaded, handling one task at a time.The counter staff only serves one customer at a time.\nJavaScript passes asynchronous tasks to web APIs, let callbacks of async calls to be executed later, and begin processing the next task.Food ordered by customer A is not cooked yet. The counter staff asks the kitchen to prepare the meal, tells customer A to go back later, and start serving customer B.\nJavaScript keeps on ready asynchronous tasks waiting in queue before execution.The way customers wait in queue is quite similar to how on ready asynchronous tasks wait in the task queue, as they all follow a first in first out manner.\n\nIllustration for Synchronous TasksIn JavaScript, synchronous tasks are executed immediately and before the execution of async tasks.\nThe counter staffâ€™s analogy can also be used to explain synchronous tasks, as if food ordered by customer B is in the holding cabinet and ready for picking up.   \nIn this case, the counter staff can directly pass the meal to and finish service for customer B, while customer A is still waiting for the meal to be ready.\nHere, service for customer B is like a synchronous task, and service for customer A is like an asynchronous task. \n\nInside asynchronous tasks: Microtask and Macrotask\nTo illustrate this, letâ€™s modify our previous story a bit. Now the McDonaldâ€™s is inside a train station. It is common that some customers have their train leaving soon and ask other customers if they can cut in line to place their order soon.\nThis scenario emphasizes the need for having both microtasks and macrotasks: we want to make it possible for high priority tasks to cut in line and be executed ahead of less prioritized ones.\nAs a result, microtasks are designed to be prioritized and executed earlier, while macrotasks are less urgent and can be deferred. In other words, microtasks will be executed before macrotasks in JavaScript.\nSo far, we can infer the execution order of the three types of tasks is: \n\n\n\n\n\n\n\n\n\nsynchronous tasks -&gt; microtasks -&gt; macrotasks.\n","slug":"single-threaded-javascript","date":"2023-02-08T19:33:14.000Z","categories_index":"","tags_index":"JavaScript","author_index":"flaming-cl"},{"id":"d7e769e271f05380381ff271e09b897f","title":"Is setState asynchronous?","content":"Whether setState is synchronous or asynchronous has become a clichÃ© these days.   \nHowever, as React is constantly evolving, a frontend programmerâ€™s answer to this question can still demonstrate some deep understanding of the framework.\nToday, letâ€™s gain a deeper understanding of some implementation mechanisms behind React.\nIdeas of this articleAlthough setState() is not inherently asynchronous, React has designed it to behave like an asynchronous function for certain reasons. This article will:\n\nSummarize why setState() behaves like an asynchronous function.\nExplore the reasons why synchronous setState() can behave asynchronously.\nClarify whether setState() behaves like a microtask or a macrotask.\n\nWhy setState() act like an async function(This section is a recap on Dan Abramovâ€™s response to the question posed in RFClarification: why is setState asynchronous?)\nIn daily life, tasks that require immediate attention are important to us, while tasks we procrastinate on are often less critical. Similarly, not every state update triggered by setState() is of the highest priority.\nThis is where the first reason of asynchronously setState comes into play: priority scheduling.\n\n\n\n\n\n\n\n\n\nReact could assign different priorities to setState() calls depending on where theyâ€™re coming from: an event handler, a network response, an animation, etc.\nReason 1: ensures concurrent featuresExampleImagine youâ€™re editing a post on social media while getting a dozen of new notification messages.If there are 100+ or even 500+ new messages, there may be no response to your keyboard input, as the browser is busy updating new notifications.\nFor the above situation, what can you do to ensure smooth text input for users?A good practice is: giving low priority to message updates, as they are less important in this case. And when a message update encounters a high priority event, we will ask the former one to yield the main thread.\nWhy asynchronous setState() benefits prioritized rendering (concurrent features) in React?This is because async-like setState() makes concurrent features possible, by delaying execution of low priority task and making room for high priority ones.\nReason 2: avoid dirty dataBesides performance optimization, avoiding dirty data is another reason not to run setState() in a synchronous way. To understand this, we need to talk about the core value of React first.\nReact In Theory\nFor React, its most fundamental principle evolved from this formula:\n\n\n\n\n\n\n\n\n\nUI &#x3D; f(state)\nThe concept behind this idea is straightforward: if you have the same input states for your application, it should always produce the same user interface (UI).\nHowever, running setState() synchronously may violate Reactâ€™s pure-function-like update processes: It is hard to ensure consistency on synchronously updated states and their props.  \nWhen a sync setState() is fired, its related props have to wait for reconciliation or flushSync to happen for corresponding updates. Such inconsistency can lead to unpredictable state updates in a React App.\nTo feel such consistency, you can try this example:\nfunction App() &#123;\n  let [count, updateCount] &#x3D; useState(0);\n  console.log(&#39;render cycle&#39;, count);\n\n  const clickMe &#x3D; () &#x3D;&gt; &#123;\n    updateCount(count + 1);\n    console.log(&#39;click me:&#39;, count);\n  &#125;\n\n  const clickFox &#x3D; () &#x3D;&gt; &#123;\n    count +&#x3D; 1;\n    console.log(&#39;click fox:&#39;, count);\n  &#125;\n\n  return (\n  &lt;&gt;\n    &lt;button onClick&#x3D;&#123;clickMe&#125;&gt;click me&lt;&#x2F;button&gt;\n    &lt;button onClick&#x3D;&#123;clickFox&#125;&gt;click fox&lt;&#x2F;button&gt;\n    &lt;Child count&#x3D;&#123;count&#125; updateCount&#x3D;&#123;updateCount&#125;&#x2F;&gt;\n  &lt;&#x2F;&gt;\n  )\n&#125;\n\nfunction Child(&#123; count, updateCount &#125;) &#123;\n  const updateOnChild &#x3D; () &#x3D;&gt; updateCount(count + 1);\n  return (&lt;button onClick&#x3D;&#123;updateOnChild&#125;&gt;&#123;count&#125;&lt;&#x2F;button&gt;)\n&#125;\nIn the above example, clickMe is a function that calls updateCount asynchronously and will trigger a re-rendering of this App. Such characteristics ensure consistency between the count state, and its corresponding props passed to the Child component.\nIf you try clickFox, every time when you click on click fox, a new value of count is immediately logged to the console. However, while â€œclick foxâ€ immediately updates the count state, the prop count still refers to the old value resulted from the last reconciliation.\nSuch inconsistency in states and props can cause unpredictable behavior in an App.\nPlease note: directly updating a state by &quot;=&quot; will not cause any re-rendering in a React App, unless we update the state with setState or useState hooks.Here we only use the click fox example to mock the situation that a state changes inconsistently with related props, and its potential issues.\nWhat makes sync setState() act asynchronouslyEvery time renderRoot or setState is triggered, React doesnâ€™t immediately start rendering in a React App. Instead, React will first schedule the updates, assigning different priority levels to each task and combining multiple tasks into one.\nBecause of this, synchronous setState() calls are collected in an updateQueue.The way updateQueue implemented gives setState() asynchronous behaviors: \n\nnormal setState() calls will be handled within a micro task queue\nconcurrent featured setState() calls are handled in a macro task queue\n\nYou might be wondering how to prove that setState() itself is synchronous?A classic example is: Prior to React 18, if you called setState() within setTimeout(), you would notice that it executes immediately, as setState called in setTimeout or native events are not collected in the updateQueue of React. \n(In React 18, this issue has been addressed, and setState() calls made within setTimeout() are now asynchronous as well)\nMicrotask or MacrotaskWhen updating, if React encounters a high-priority task, it will not execute the next low-priority task and schedule the highest-priority task to be executed.\nHow does React implement this (let high priority tasks cut in line)?When it comes to the JavaScript event loop, a common method of interrupting is to let the newly added microtask interrupt the execution of existing macro tasks.We also know that React update functions (setState) are often processed as microtasks.\nTake the concurrent feature as an example:To interrupt low-priority tasks, we mark the tasks in a concurrent feature API as low-priority and put them in a macro task queue.In this way, when higher-priority microtask updates appear, they can jump ahead of the current low-priority macro tasks and be processed first.\nReference\nRFClarification: why is setState asynchronous?\nAutomatic batching for fewer renders in React 18\n\n","slug":"async-setState","date":"2023-02-07T20:07:27.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"cde1a0943957747e6b9bbb6c795024ad","title":"Ideas behind concurrent features","content":"Do React concurrent features mean multitasking?No. React concurrent features are not about multitasking.This is because the JavaScript engine is single-threaded (can only do one thing at one time).So there is no magic for React to simultaneously handle user events while rendering a large list.\nIf so, what does React do to avoid stutters when running CPU heavy tasks?In fact, React tries to avoid CPU bottlenecks by running one task, stopping it, running another, and so forth.Sounds like a micro operating system, right? \nBut concurrent features will not allow tasks to freely compete for sources.Instead, they will label different tasks with different priority: low priority running tasks will yield the main thread to high priority tasks to ensure performance.\nThis is quite similar to how we answer a second phone call:\n\n\n\n\n\n\n\n\n\nAssume there comes a food delivery call, while we are calling a friend for a casual chat.Since a food delivery call is more urgent than a casual chat, we hold the chat and answer the delivery call.\n\nReact does the same thing. It can pause a less prioritized rendering task and yield to more urgent tasks, such as keyboard events. This is implemented as concurrent features since React 18.\nCan you give some examples about React concurrent features?Concurrent features: startTransition(), useTransition(), useDeferredValue()By using the above APIs, you are telling React to give lower priority to things you put in them. \n1ï¼‰useDeferredValue(value)\n\nexample: input value of a search bar\nresult: updates of the input value will be deferred, just like what â€œdebounceâ€ does\n\n2ï¼‰startTransition(callback)\n\nexample: a function to update a large list\nresult: When updating the large list, if there comes a keyboard event, React will pause the ongoing update and turn to the user event.\n\nWhat enables React to run the concurrent features?Time slicing.After V16, React started to embrace time slicing to ensure an interruptible render phase.This means React can insert urgent browser tasks among small tasks from the render phase to avoid stutter.\nTo understand more about time slicing, go to this post\nReferences[1] Visualization of async rendering and synchronous rendering in React, Andrew Clark[2] useTransition, React Docs[3] useDeferredValue, React Docs\n","slug":"simple-ideas-about-React-Concurrent-mode","date":"2023-02-06T17:21:10.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"de1e92f12f92aa6a57725fd15aeb7de1","title":"React Source Code Little by Little 3 - Render Phase","content":"Recap: Time Sliced Work LoopFrom the time slicing post, we have known React implements an interruptible render phase by a conditional while loop: once shouldYield turns True, the current reconciliation job can be paused, leaving the main thread to more prioritized jobs, like a user event.\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\nToday we are going to talk about the render phase of React, which is implemented via performUnitOfWork inside each work loop.\nQuestion: Do you think where we should put our code for the commit phase?\n\nWe should put it outside the breakable while loop.      \nThis is because the commit phase can not be paused: we do not want to see our App rendered with some half updated states.\n\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        performUnitOfWork(\n            workInProgress\n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    commitWork(); // the commit phase\n    requestIdleCallback(workLoop)\n&#125;\n\n\n\n\nThe Render PhasePerformUnitOfWork (the render phase) mainly does two things: beginWork and completeWork. Its code could be written like this:\nlet workInProgress = null;\n\nfunction performUnitOfWork(fiber: FiberNode) &#123;\n    const next = beginWork(fiber);\n    fiber.memorizedProps = fiber.pendingProps;\n\n    if (next === null) &#123;\n        completeUnitOfWork(fiber);\n    &#125; else &#123;\n        workInProgress = next;\n    &#125;\n&#125;\nAn Overview of PerformUnitOfWorkBefore understanding key responsibilities of performUnitOfWork, we first have an overview about how React calls performUnitOfWork to reconcile a Fiber tree.\n\nbeginWorkWhat does beginWork do?Each time, performUnitOfWork calls beginWork with the WIP (work in progress) fiber node to do the reconciliation job and return a reconciled child Fiber node (return null if no child). \nExecution order of beginWork calls  The execution order of beginWork calls is similar to a preorder traversal of a tree, like succession to a monarchyâ€™s throne:\n\n\n\n\n\n\n\n\n\n1st kid âž¡ 1st grandchildren âž¡ 1st great-grandchildren âž¡ â€¦ âž¡ the 1st no-kid offspringâž¡ second in line sibling âž¡ 1st kid of second in line sibling âž¡ â€¦\n  True or False: The 1st Fiber node enters completeWork is the deepest node in a Fiber tree. \n          \n          False. The first Fiber node enters completeWork is the left most leaf node in an App.\n          \n     \n\nAfter beginWorkWhen beginWork finishes its work, we update the current props in the Fiber node.The next step depends on whether the current Fiber node has a child node:\n\nchild âœ…, performUnitOfWork will pass the child to the next performUnitOfWork call.\nchild âŒ, performUnitOfWork will leave the current node to completeUnitOfWork.\n\ncompleteUnitOfWorkThen, performUnitOfWork calls completeUnitOfWork:\nfunction completeUnitOfWork(fiber: FiberNode) &#123;\n    let node: FiberNode | null = fiber;\n\n    do &#123;\n        completeWork(node); \n        const sibling = node.sibling;\n\n        if (sibling !== null) &#123;\n            workInProgress = sibling;\n            return;\n        &#125;\n\n        node = node.return;\n        workInProgress = node;\n    &#125; while (node !== null);\n&#125;\nInside completeUnitOfWork, we first call completeWork to create a DOM instance for the WIP fiber node and handle its effects&#x2F;flags. After that, the while loop has 3 options:\n\nOption 1, the WIP node has a sibling node âœ…: beginWork(sibling)\nOption 2, sibling node âŒ , parent node âœ… : completeWork(parent)\nOption 3, sibling node âŒ , parent node âŒ : stop the work loop\n\nTest your understandingNow we have had an overview of the reconciliation work loop.To test how you understand what we have learned, give it a whirl on the following question.\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nQuestion: Please list all the beginWork and completeWork calls of this App during a render phase in sequence.\nFor example, 1. beginWork(hostFiberRoot) 2. beginWork(App) 3. beginWork(div)\n\n\n\n\nNote: DIV is a host component. â€œlittle by littleâ€ is a text component.\nInterview TrickYou may wonder why we spend so much time on a general understanding of the render phase. By understanding it, you can solve many interview questions on the rendering path of an APP.\nLet us look at an interview question:\nimport React, &#123; useEffect &#125; from \"react\";\n\nfunction A() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount A\");\n  &#125;, []);\n  console.log(\"A\");\n  return &lt;B />;\n&#125;\n\nfunction B() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount B\");\n  &#125;, []);\n  console.log(\"B\");\n  return &lt;C />;\n&#125;\n\nfunction C() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount C\");\n  &#125;, []);\n  console.log(\"C\");\n  return null;\n&#125;\n\nfunction D() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount D\");\n  &#125;, []);\n  console.log(\"D\");\n  return null;\n&#125;\n\nfunction App() &#123;\n  useEffect(() => &#123;\n    console.log(\"Mount App\");\n  &#125;, []);\n  console.log(\"App\");\n  return (\n    &lt;div>\n      &lt;A />\n      &lt;D />\n    &lt;/div>\n  );\n&#125;\n\nexport default App;\nWhat does the above code snippet output by calling console.log?App    \nA    \nB    \nC    \nD     \nMount C    \nMount B     \nMount A    \nMount D   \nMount App  \n\n\nConsole.log(â€œXâ€) is called when we enter a component. \n\n\n\n\n\n\n\n\nOrders of entering a component are the same as how we call beginWork (like a preorder traversal).\n\nConsole.log(â€œMount Xâ€) inside useEffect(() &#x3D;&gt; {}, []) is called after a component is rendered. \n\n\n\n\n\n\n\n\nOrders of rendering a component are the same as how we call completeWork (like a postorder traversal).\n\n\nBut can you tell the reasons for your answer? It is time to take a closer look at beginWork and completeWork.\n","slug":"react-render-phase","date":"2023-01-13T13:41:00.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"6f24cb5d48daf65e1958eb9ee89fd0c6","title":"Trie based router","content":"Why trie based routerIf you do not have performance issues, adopting a trie based router might become a premature optimization. In this case, Regex based routing is fast enough, as Regex are compiled down to native code in modern browsers, like Chrome.\nHowever, if you feel tradition MVC routing results in performance pressure on your web App, you can take a look at trie based router. Here is an example from Ayende Rahien.   \n\n\n\n\n\n\n\n\n\nTraditional MVC routing infrastructure can consume a significant amount of time,leaving little time for handling actual requests.By using a trie based router, it is possible to reduce time spent on routing infrastructure,and increase time spent on actual request handling.\nHow to implement Router trieA route mainly does two things: registering a route with a function; matching a route.Here we use trie to register and match routes.\n1. Register a routeFirst, split the route into an array of routes.e.g. â€œ&#x2F;courses&#x2F;:idâ€ &#x3D;&gt; [â€œcoursesâ€, â€œ:idâ€]\nconst add = (route) => &#123;\n    if (typeof route !== 'string') &#123;\n        throw TypeError('route should be string');\n    &#125;\n    this.currentRoutes = splitRoute(route);\n    return this.createTrieNode(0, this.trie);\n&#125;\nNext, recursively add each segment of the route array to our trie.\n\n1&#x2F; Handle â€œ:â€ for dynamic values, â€œ*â€ for wildcard (any value)\n2&#x2F; If a segment is found in our trie, check the next one\nâ€œcoursesâ€ is shared in the trie, if we have both courses&#x2F;:id and courses&#x2F;ranking\n\n\n3&#x2F; If not found, create a trie node for this segment const createTrieNode = (index, trie) => &#123;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n        \n    let node = null;\n    if (HAS_SPECIAL_SYMBOL) &#123;\n        handleSpecialSymbol();\n    &#125; else if (trie.nodes.has(thisRoute)) &#123;\n        node = trie.nodes[thisRoute];\n    &#125; else &#123;\n        node = this.createNewNodes();\n        trie.nodes[thisRoute] = node;     \n    &#125;\n\n    return this.createTrieNode(index + 1, node);\n&#125;\n\n2. Match a routeLogics for match() a route is quite similar to add().The main difference is in match() we also handle params for a route (if found).\nconst match = (route) => &#123;\n    this.currentRoutes = splitRoute(route);\n    this.currentParams = &#123;&#125;;\n        \n    const node = search(0, this.trie);\n    if (!node) return undefined;\n        \n    node = new Map(node);\n    node.params = this.currentParams;\n    return node;\n&#125;\nWhat does search() do?If a node is found, search() recursively calls itself, with the next segment and the matching node as arguments.\nconst search = (index, trie) => &#123;\n    if (trie === undefined) return trie;\n    const thisRoute = this.currentRoutes[index];\n    if (thisRoute === undefined) return trie;\n\n    if (trie.nodes.has(thisRoute)) &#123;\n        return search(index + 1, trie.nodes[thisRoute]);\n    &#125;\n\n    if (trie.name) &#123;\n        // add params\n    &#125;\n\n    if (trie.wildCard) &#123;\n        // add params\n    &#125;\n\n    return search(index + 1);\n&#125;\nFor full implementation, check here.\nReferences[1] Trie based routing, Ayende Rahien[2] A composable trie based router, Wayfarer[3] Trie based routing instead of Regex based routing, React router\n","slug":"dsa_for_web_trie_router","date":"2022-12-21T18:04:15.000Z","categories_index":"","tags_index":"DSA for web dev","author_index":"flaming-cl"},{"id":"1f330e0fd561e9de08c865f67f8ae6c9","title":"React Source Code Little by Little 2 - Fiber Tree","content":"\n\n\n\n\n\n\n\n\nPlato said life is like being chained up in a cave, forced to watch shadows flitting across a stone wall.\nWe are not talking about philosophy today, but use Allegory of the Cave to describe the relationship between React applications and what is under the hood:\nReact applications we see today are mainly results of the render phase and the commit phase.Just like shadows in the eyes of prisoners are results of sun reflection and real world activities.\n\nWhat is under the hoodBefore we see any changes in an application, React does three things: Scheduling, Rendering and commit. What are these? In plain English, they are just:\n\nScheduling ðŸ—“ï¸: schedule and manage tasks to run\nRender ðŸ”Ž ðŸŒ² ðŸ: figure out changes made in React applications\nCommit â˜‘ï¸ : apply these changes to browser DOM\n\nTo understand React, we will start from the render phase. To understand the render phase, we need to understand the React Fiber data structure.\nIn this post, I will cover 2 topics about React Fiber:\n\nHow does React create the first Fiber node?\nWhat are the main properties of a Fiber node?\n\n\nHow does React build a Fiber Tree from the first Fiber node during mounting?\n\nInside React Reconciliation: Fiber TreesFrequent DOM manipulations are expensive for complicated web applications.In this case, we had better only applies changes to the real DOM during state&#x2F;props updates.But changes might spread all over the whole tree, to locate them, we can compare two versions (previous &amp; current) of a virtual DOM tree. This process is called Reconciliation in React.\nQuestion: What is a virtual DOM tree called in React 18?Fiber tree, a singly linked list tree.To understand Fiber tree, we can start from the most basic unit of it, a Fiber node.\nHow does React generate the first Fiber nodeA Fiber node is just a plain JavaScript object.But it may be the object you have never seen before, since it is not exposed to React users.Let us start from something we are familiar withâ€”React Components.\nReact Components, Elements, Fiber NodeThe process of building a Fiber node is the process of converting React Component JSX &#x3D;&gt; a React Element &#x3D;&gt; a Fiber node. \n JSX \n\n\n\n\n\n\n\n\n\n\n\nA syntax extension to JavaScript that allows writing HTML in React components\n\n\n\n React Element \n\n\n\n\n\n\n\n\n\n\n\nThe smallest building blocks of React apps, describing what to render to a React UI environment\n\n\n\n Fiber node \n\n\n\n\n\n\n\n\n\n\n\nA basic unit of work to locate or commit changes in React applications\n\n\n\nFrom React Component to React ElementWe know that React components return JSX. But what does JSX produces?\nconst App = () => &#123;\n    return (\n        &lt;div>\n            react\n            &lt;span>\n                little by little\n            &lt;/span>\n        &lt;/div>\n    )\n&#125;\nReactDOM.createRoot(rootElement).render(&lt;App />);\nJSX produces React elements.For example, App is a React component; &lt;App &#x2F; &gt; is a React element in the form of JSX.If you put &lt;App &#x2F; &gt; into Babel, you will get:\n/*#__PURE__*/React.createElement(App, null);\nIt is just a JavaScript object:\nconsole.log(React.createElement(App, null));\n\n/*\n&#123;\ntype: Æ’ App(), // e.g. functional component, or HTML tag type like div, p, h1\nkey: null, // e.g. keys you set up in a React component\nref: null,\nprops: &#123;&#125;, // e.g. React component props\n_store: &#123;&#125;,\n_owner: null,\n&#125;\n*/\nTake a closer look at this React Element object, and answer this question:\nCan a React Element be the unit of work to do the Reconciliation job? \n\n\nNo. For Reconciliation, a React element can be too static and isolated:\n\nData stored in it is comparatively static. It mainly explains what this React element looks like.\n\n\n\n\n\n\n\n\nFor reconciliation, we need more dynamic data about its state&#x2F;effect changes or priority scheduling.\n\nIt does not show connections with its children&#x2F;sibling&#x2F;parent Elements.\n\n\n\n\n\n\n\n\nWhen we have finished processing it, we have no way to find the next unit of work.\n\n\nFor reconciliation, we need an upgraded version of React Element. That is where Fiber node comes in.\n\n\n\nFrom React Element to Fiber nodeWe can create a Fiber root node for the React element &lt;App &#x2F; &gt;, by calling:\nconst rootElement = document.getElementById(\"root\");\nReactDOM.createRoot(rootElement).render(&lt;App />);\n\nTo see what is inside a Fiber node (React 18.2.0), you can try this:\nconst reactContainerKey = Object.keys(rootElement)[0]; // __reactContainer$cjvrzgbs4i4 \nconsole.log(rootElement[reactContainerKey]) // Fiber root node\n\nTo make it easier to understand, I break down properties of a Fiber node object into 4 parts:\n\nBasic Fiber node info\nTree pointers\nEffect &amp; reconciliation\nScheduling\n\nHere is a cheatsheet for a React Fiber node:\n\nAt this moment, just take a glimpse at this Fiber node.Knowing it also tells something about Reconciliation, Scheduling and its neighbor nodes is enough at this moment. \nHow does React build a Fiber tree from the Fiber root node?Now we have created a Fiber root node.Before mount (first time rendering), React does three things:\n\nCreate a Fiber root node for the whole App.\nCreate a Host Fiber node for the rootElement DOM element.\nLink the Fiber root node with the host Fiber node, using the â€œcurrentâ€ pointer.\n\n\nDuring mounting, React will also create an alternative host Fiber node.This is different from our existing one, as its child node is not null but a tree of Fiber nodes, which correspond to each React element listed in the app.\nThe alternative host Fiber node, along with its descendant Fiber nodes, is called the workInProgress (WIP) Fiber tree.\nLook at the above pic, you may wonder: Why two host root nodes? What is double buffering? \n\n\nHere is an illustration from game programming patterns:\n\n\n\n\n\n\n\n\n\nImagine we are watching a play.When scene 1 is finished, we will have a 5-minute scene transition, leaving the audience in dark and silence. This is normal in a real world theatre play.But if we leave game players in a black screen for a few seconds, this may drive people nuts.\nIn both game programming and React, we hope to avoid this blank transition by a technique called Double Buffering.Back to our theatre play example, we avoid the silent transition by running two stages (double buffering): \n\nstage A is on show for the current scene \nstage B is adjusting lights or removing&#x2F;changing play props for the next scene\n\nOnce the current scene is finished on stage A, we immediately light on stage B to go to the next scene seamlessly. Now stage A is in dark preparing the next scene settings. \nSo in React, double buffering means switching between the current fiber tree and a workInProgress fiber tree for seamless transitions between rendering.\n\n\n\n\nWe therefore have finished a simple tour about first time rendering in React.\nReferences[1] Double Buffering[2] Allegory of the Cave\n","slug":"react-fiber-tree","date":"2022-11-23T04:40:35.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"},{"id":"87eff45d285eb86c0eaa49c27b6abfb9","title":"Exploring the Benefits of Locality in Memory","content":"As stated in Computer Systems: A Programmerâ€™s Perspective:\n\n\n\n\n\n\n\n\n\nWell-written computer programs tend to exhibit good locality\nWhat is localityIf you haven't heard of locality, click here.\n\n \n\n\n\n\n\n\n\n\n\nLocality is often described as temporal locality and spatial locality.\n1. Spatial localityGood practice: reference a memory location and then its neighbors\nPoor spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (j &#x3D; 0; j &lt; N; j++)\n    for (i &#x3D;0: i &lt; M; i++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code jumping through elements of different rows in the matrix.\nAssume you are going to buy groceries and books. With poor spatial locality, you  do this:\n\nbuy tomatoes first, and go to a book store for a Math book.\nback to the grocery store for milk, and go to the book store again for a comic book.\n\nBetter spatial localityint sumarraycols (int a[M][N]) &#123;\n  int i, j, sum &#x3D; 0;\n  for (i &#x3D; 0; i &lt; M; i++)\n    for (j &#x3D;0: j &lt; N; j++)\n      sum+ &#x3D; a[i][j]:\n  return sum;\n&#125;\nThis code reads all the elements in a row and then the next row.\nBack to our grocery example, this time you buy everything from the grocery store first.Later to buy all the books you need from the book store.\n2. Temporal localityGood practice: reference a memory location multiple times\nGood temporal localityOur code above repeatedly reference the same variables (i, j) and enjoy good temporal locality.\n\n\n\nExample in JavaScriptCan we have good spatial locality if we loop cols before rows like this?\nfunction farAccess(data) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      data[j * ROWS + i].x = 1;\n    &#125;\n  &#125;\n&#125;\nLetâ€™s look at an example given by Yonatan Kra:\n1&#x2F; Create an array of 1,000,000 instances.\nconst ROWS = 1000, COLS = 1000, REPEATS = 1000;\nconst testArray = new Array(ROWS * COLS).fill(0).map((a, i) => new Boom(i));\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n2:Boom &#123;id: 2, x: 0&#125;\n3:Boom &#123;id: 3, x: 0&#125;\n...\n999999:Boom &#123;id: 999999, x: 0&#125;\n2&#x2F; Create a tricky array.\nconst trickyArray = new Array(ROWS * COLS).fill(0);\nfor (let col = 0; col &lt; COLS; col++) &#123;\n    for (let row = 0; row &lt; ROWS; row++) &#123;\n        trickyArray[row * ROWS + col] = arr[col * COLS + row];\n    &#125;\n&#125;\n3&#x2F; Write two functions with good&#x2F;bad spatial locality. \nfunction runGoodSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; ROWS; i++) &#123;\n    for (let j = 0; j &lt; COLS; j++) &#123;\n      arr[i * ROWS + j].x = 0;\n    &#125;\n  &#125;\n&#125;\n\nfunction runPoorSpatialLocality(arr) &#123;\n  for (let i = 0; i &lt; COLS; i++) &#123;\n    for (let j = 0; j &lt; ROWS; j++) &#123;\n      arr[j * ROWS + i].x = 0;\n    &#125;\n  &#125;\n&#125;\n4&#x2F; Test performance\nfunction timeit(cb, type) &#123;\n    console.log(`Started data $&#123;type&#125;`);\n    const start = performance.now();\n    for (let i = 0; i &lt; repeats; i++) &#123;\n        cb();\n    &#125;\n    const end = performance.now();\n    console.log(\n        `Finished data locality test run in $&#123;((end - start) / 1000).toFixed(\n            4\n        )&#125; seconds`\n    );\n    return end - start;\n&#125;\n\ntimeit(() => runGoodSpatialLocality(testArray), \"good\");\nsetTimeout(() => &#123;\n    timeit(() => runPoorSpatialLocality(testArray), \"bad\");\n    setTimeout(() => &#123;\n        timeit(() => runPoorSpatialLocality(trickyArray), \"tricky\");\n    &#125;, 2000);\n&#125;, 2000);\n5&#x2F; ResultsThe second function call with bad locality is more than 2 times slower.This is because it makes the CPU chasing its tail to jump between N (length of a row) stride of memory, during each access.But why the third function call with bad locality and the tricky array is still fast? \nFinished good data locality test in 5.1799 seconds\nFinished bad data locality test in 13.9438 seconds\nFinished tricky data locality test in 5.4242 seconds\nBecause our tricky array still access 1-stride of an array:Although we access the whole array by index 0, 1000, â€¦our tricky array just put elements with 1-stride of memory on index 0, 1000, 2000, â€¦ like this:\n// trickArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1000, x: 0&#125;\n1000:Boom &#123;id: 1, x: 0&#125;\n1001:Boom &#123;id: 1001, x: 0&#125;\n2000:Boom &#123;id: 2, x: 0&#125;\n...\n\n// testArray:\n0:Boom &#123;id: 0, x: 0&#125;\n1:Boom &#123;id: 1, x: 0&#125;\n1000:Boom &#123;id: 1000, x: 0&#125;\n2000:Boom &#123;id: 1000, x: 0&#125;\n...\nNow we get the answer: Yes.Even though we run a COL loop first and a ROW loop later,as we still access a memory location and its neighbors in memory,we can have good spatial locality.\nReferences[1] Computer Systems: A Programmerâ€™s Perspective[2] Memory in Javascriptâ€”Beyond Leaks[3] Stride, Caches, CS61C lab12\n","slug":"locality","date":"2022-11-10T18:04:15.000Z","categories_index":"","tags_index":"Memory","author_index":"flaming-cl"},{"id":"aae100d7d9b058fd9820b29b99447c0a","title":"React Source Code Little by Little 1 -  Time Slicing","content":"You may have heard people saying â€œReact is fastâ€ as it uses virtual DOM.But is virtual DOM the only thing you can think of when talking about React performance?In fact React has done many things to handle performance issues.\nToday I will talk about Time Slicing.A technique React uses to solve performance bottleneck.\nEvent Loop and CPU bottlenecksEvent LoopModern browsers run a continuous event loop at a certain frequency - e.g. 60Hz (refresh 60 times a second). For smooth and responsive experience, browsers try to complete tasks within each event loop execution, aka a frame.\n\nFor 60Hz refresh rate devices, each execution frame has a budget of 16.66ms (1 second &#x2F; 60).\nCPU bottlenecksWithin such a shoestring budget, browsers have to handle a pipeline of work like this:\n\nIf any step in this pipeline needs more than 16.66ms, no time will be left for the upcoming work in this frame.This means we will not have time for style calculations, layout, paint and compositing, when we spend too much time on JavaScript jobs.When this lasts for 2 or 3 seconds, users will feel your website is slow.\nHow does React avoid this scenario?React sets up an interval for running JavaScript tasks (5ms).When running out of this interval, React will pause its current tasks and give back control to the main thread, letting it perform high priority tasks (painting or user events).After the main thread has finished prioritized jobs, React goes back to where it stopped and continues working.\nAs you may have noticed, the key here is to make React interruptible.\nTime Slicing and Interruptible ReactAssume we have a large application with 500+ components to render.\nWhile rendering these components, how does React ensure responsiveness for keyboard or mouse events?Before React 16, the render phase was synchronize and uninterruptible.The browser therefore would be easily occupied by CPU-hungry tasks,and unable to give prompt responses to user events.Take a look at this video to see what CPU-heavy tasks could be like.\nSo, how did React overcome this?Answer: Time Slicing.\nHere is a picture of time slicing in React (idea of Andrew Clark from the React core team).\n\nInterruptible render phaseAfter version 16, React started using Fiber reconciler to ensure the render phase is interruptible. It breaks down the render phase into time slices so that it can pause current work to run more urgent tasks, like user inputs.As shown in the above picture, time slicing enables browser events to cut in line during the render phase. This helps React to avoid â€œhiccupâ€ moments.\nUninterruptible commit phaseUnlike the render phase, the commit phase can not be interrupted.You can think of these two like a movie screenplay and a movie on show.When a movie is on (the commit phase), theatres will not suddenly stop playing or change its order of scenes. Just like React will not draw some semi-calculated UI or suddenly stop the commit phase.\nInterruptible Work LoopBefore version 16, React reconciler is implemented by call stack recursion. However, stack Reconciliation will not allow pauses on the running render phase.As mentioned earlier, a high performance render phase is time sliced and interruptible. To implement this, we can change the call stack recursion to conditional while loop recursion:\nfunction workLoop(deadline) &#123;\n    let shouldYield = false\n    while (workInProgress !== null &amp;&amp; !shouldYield) &#123;\n        // next workInprogress is set within performUnitOfWork\n        performUnitOfWork(\n            workInProgress \n        )\n        shouldYield = deadline.timeRemaining() &lt; 1\n    &#125;\n    requestIdleCallback(workLoop)\n&#125;\n\nwhile (workInProgress !&#x3D;&#x3D; null &amp;&amp; !shouldYield)\n\n\n\n\n\n\n\n\nThis enables us to stop the workLoop, especially when there is no time left in each frame (shouldYield).  \n\nrequestIdleCallback\n\n\n\n\n\n\n\n\nCheck whether the main thread is idle for running sliced tasks.\n\n\nFiber ReconcilerThis interruptable reconciler is called Fiber reconciler in React.To know more about React Fiber, take a look at this post first: React Fiber Tree.\nReferences[1] Sneak Peek: Beyond React 16, Dan Abramov[1] Build your own React, Rodrigo Pombo[2] Event loop: microtasks and macrotasks, javascript.info[3] Visualization of async rendering and synchronous rendering in React, Andrew Clark[4] Reconciliation, React official documents[5] Rendering Performance, Paul Lewis[6] Frame timing, W3C\n","slug":"time-slicing-react","date":"2022-09-28T22:49:47.000Z","categories_index":"","tags_index":"React","author_index":"flaming-cl"}]